{
    "risk_web": [
        {
            "name": "MsSQL 盲目 SQL 注入（頻外）",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "嚴重",
            "cvss": "9.4",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/showthread.asp",
            "entity": "id (Parameter)",
            "risk": "有可能檢視、修改或刪除資料庫項目和表格\n",
            "cause": "未正確地消毒使用者所輸入的危險字元",
            "solution": "檢查危險字元注入可能的解決方案",
            "mark": "id=0%3Bexec+master+..xp_dirtree+%27%5C%5Cv3-ping-21-4bdf443d-bf44-46ad-89de-ad008e710c31.adns.appsechcl.com%5Cdir%27--",
            "solution_description": "有可能檢視、修改或刪除資料庫項目和表格此軟體會使用受到外部影響的輸入，來建構全部或部分的 SQL 指令，但無法在傳送到資料庫時，讓可以修改 SQL 指令的元素失效。當使用者可控制的輸入中，沒有足夠的移除或引用 SQL 語法時，產生的 SQL 查詢可能導致系統將這些輸入解譯為 SQL，而非一般使用者資料。這可用於變更查詢邏輯以略過安全性檢查，或插入其他可修改後端資料庫的陳述式，可能包含執行系統指令。舉例來說，我們有一個包含登入表單的 HTML 頁面，最後會採用使用者輸入，在資料庫上執行下列 SQL 查詢： SELECT * FROM accounts WHERE username='$user' AND password='$pass' $user 和 $pass 這兩個變數包含使用者在登入表單中所輸入的使用者憑證。如果使用者輸入「jsmith」作為使用者名稱，並且將「Demo1234」作為密碼，SQL 查詢看起來會像這樣： SELECT * FROM accounts WHERE username='jsmith' AND password='Demo1234' 但如果使用者輸入「'」（單引號）作為使用者名稱和密碼，SQL 查詢看起來會像這樣： SELECT * FROM accounts WHERE username=''' AND password=''' 這當然就是型態異常的 SQL 查詢，這會呼叫錯誤訊息（可能在 HTTP 回應中傳回）。這類錯誤會告知攻擊者 SQL 已成功注入，導致攻擊者嘗試進一步的攻擊向量。盲目 SQL 注入與 SQL 注入相似，其差別在於攻擊者如要利用盲目 SQL，不需要在回應中查詢 SQL 錯誤。因此 AppScan 用於識別的方法也不一樣。AppScan 不會嘗試呼叫 SQL 錯誤，但會找出容易遭受 SQL 注入的參數。AppScan 可透過讓 SQL 伺服器本身執行我們可識別的外部要求，來執行這個動作。這項技術需要傳送弱點參數（在 SQL 查詢中嵌入的參數）已經過修改的要求，以便外部要求表示資料是否在 SQL 查詢的脈絡中使用。每個 SQL 伺服器的修改都是獨一無二的。頻外盲目 SQL 注入背後的概念是，即使攻擊者沒有直接從資料庫中收到資料，也能夠收到資料庫的內容（透過錯誤訊息或遭洩漏資訊的形式）。",
            "solution_suggest": "以下是幾種減輕風險的技巧：[1] 策略：程式庫或架構使用檢查過且不容許此弱點的程式庫或架構，或提供使其更容易避免的建構項。[2] 策略：參數化如果可行，請使用結構化機制來自動強制分開資料與程式碼。這些機制可能可以自動提供相關的引用、編碼和驗證，而不是在每次產生輸出時，都依賴開發人員來提供。[3] 策略：環境強化 使用完成必要作業所需的最低專用權，來執行程式碼。[4] 策略：輸出編碼如果儘管有風險，您還是需要使用動態產生的查詢字串或指令，適當地括住引數且避免在這些引數內使用任何特殊字元。[5] 策略：輸入驗證假設所有輸入都是惡意的。請使用「接受已知良好」輸入驗證策略：嚴格符合規格的可接受輸入白名單。拒絕未嚴格符合規格的任何輸入，或將其轉換成嚴格符合規格者。請勿只靠使用黑名單來偵測惡意或形態異常的輸入。不過，在偵測潛在攻擊或判斷哪些輸入因形態異常而應該斷然拒絕時，黑名單就很有用。以下是保護 Web 應用程式免於遭受 SQL 注入攻擊的兩種可能方式：[1] 使用儲存程序，而不用動態建置的 SQL 查詢字串。參數傳給 SQL Server 儲存程序的方式，會防止使用單引號和連字號。如何在 ASP.NET 中使用儲存程序的範例如下： ' Visual Basic example Dim DS As DataSet Dim MyConnection As SqlConnection Dim MyCommand As SqlDataAdapter Dim SelectCommand As String = \"select * from users where username = @username\" ... MyCommand.SelectCommand.Parameters.Add(New SqlParameter(\"@username\", SqlDbType.NVarChar, 20)) MyCommand.SelectCommand.Parameters(\"@username\").Value = UserNameField.Value // C# example String selectCmd = \"select * from Authors where state = @username\"; SqlConnection myConnection = new SqlConnection(\"server=...\"); SqlDataAdapter myCommand = new SqlDataAdapter(selectCmd, myConnection); myCommand.SelectCommand.Parameters.Add(new SqlParameter(\"@username\", SqlDbType.NVarChar, 20)); myCommand.SelectCommand.Parameters[\"@username\"].Value = UserNameField.Value; [2] 您可以利用驗證控制項，將輸入驗證新增到「Web 表單」頁面中。驗證控制項提供適用於標準驗證之所有一般類型的簡易使用機制（例如：測試日期是否有效，或值是否在範圍內），以及用來提供自訂編寫驗證的方式。此外，驗證控制項也可讓您完整自訂向使用者顯示錯誤資訊的方式。驗證控制項可以搭配「Web 表單」頁面類別檔所處理的任何控制項來使用，其中包括 HTML 和 Web 伺服器控制項。如果要確定使用者輸入只包含有效值，您可以使用下列其中一個驗證控制項：a. \"RangeValidator\"：檢查使用者的輸入（值）是否在指定的上下界限之間。您可以檢查數字、英文字母和日期之配對內的範圍。b. \"RegularExpressionValidator\"：檢查輸入是否符合正規表示式所定義的型樣。這類型的驗證可讓您檢查可預期的字元序列，例如：社會保險號碼、電子郵件位址、電話號碼、郵遞區號等等中的字元序列。重要注意事項：驗證控制項不會封鎖使用者輸入，或變更頁面處理流程；它們只會設定錯誤狀態，以及產生錯誤訊息。在執行進一步的應用程式專屬動作之前，程式設計師負責測試程式碼中的控制項狀態。檢查使用者輸入有效性有兩種方式：1. 測試一般錯誤狀態：在您的程式碼中，測試頁面的 IsValid 內容。這個內容會累積頁面上所有驗證控制項的 IsValid 內容值（使用邏輯 AND）。如果其中一個驗證控制項設為無效，頁面內容便會傳回 False。2. 測試個別控制項的錯誤狀態：在迴圈中處理頁面的驗證器集合，集合中含有指向所有驗證控制項的參照。之後，您便可以檢查每個驗證控制項的 IsValid 內容。** 備妥陳述式：保護您的應用程式免於遭受 SQL 注入（亦即，惡意竄改 SQL 參數）有三種可能的方式。請利用下列方式，而非動態建置 SQL 陳述式：[1] PreparedStatement，經過前置編譯而存放在 PreparedStatement 物件儲存區中。PreparedStatement 定義用來登錄輸入參數的設定元，輸入參數相容於支援的 JDBC SQL 資料類型。例如，setString 應該用於 VARCHAR 或 LONGVARCHAR 類型的輸入參數（請參閱 Java API，以取得進一步的詳細資料）。這個設定輸入參數的方式，可以防止攻擊者注入不正確的字元（如單引號）來操作 SQL 陳述式。如何使用 J2EE 中之 PreparedStatement 的範例： // J2EE PreparedStatemenet Example // Get a connection to the database Connection myConnection; if (isDataSourceEnabled()) { // using the DataSource to get a managed connection Context ctx = new InitialContext(); myConnection = ((DataSource)ctx.lookup(datasourceName)).getConnection(dbUserName, dbPassword); } else { try { // using the DriverManager to get a JDBC connection Class.forName(jdbcDriverClassPath); myConnection = DriverManager.getConnection(jdbcURL, dbUserName, dbPassword); } catch (ClassNotFoundException e) { ... } } ... try { PreparedStatement myStatement = myConnection.prepareStatement(\"select * from users where username = ?\"); myStatement.setString(1, userNameField); ResultSet rs = myStatement.executeQuery(); ... rs.close(); } catch (SQLException sqlException) { ... } finally { myStatement.close(); myConnection.close(); } [2] CallableStatement，延伸 PreparedStatement 來執行資料庫 SQL 儲存程序。這個類別繼承 PreparedStatement 的輸入設定元（請參閱上面的 [1]）。下列範例假設已建立好這個資料庫儲存程序：CREATE PROCEDURE select_user (@username varchar(20))AS SELECT * FROM USERS WHERE USERNAME = @username;如何利用 J2EE 中的 CallableStatement 來執行上述儲存程序的範例： // J2EE PreparedStatemenet Example // Get a connection to the database Connection myConnection; if (isDataSourceEnabled()) { // using the DataSource to get a managed connection Context ctx = new InitialContext(); myConnection = ((DataSource)ctx.lookup(datasourceName)).getConnection(dbUserName, dbPassword); } else { try { // using the DriverManager to get a JDBC connection Class.forName(jdbcDriverClassPath); myConnection = DriverManager.getConnection(jdbcURL, dbUserName, dbPassword); } catch (ClassNotFoundException e) { ... } } ... try { PreparedStatement myStatement = myConnection.prepareCall(\"{?= call select_user ?,?}\"); myStatement.setString(1, userNameField); myStatement.registerOutParameter(1, Types.VARCHAR); ResultSet rs = myStatement.executeQuery(); ... rs.close(); } catch (SQLException sqlException) { ... } finally { myStatement.close(); myConnection.close(); } [3] Entity Bean，在持續性儲存庫機制中代表 EJB 商業物件。Entity Bean 有兩種類型：Bean 管理和儲存器管理。當使用 Bean 管理的持續性時，開發人員負責撰寫存取資料庫的 SQL 程式碼（請參閱上述 [1] 和 [2] 區段）。當使用儲存器管理的持續性時，EJB 儲存器會自動產生 SQL 程式碼。因此，儲存器要負責防止惡意嘗試竄改產生的 SQL 程式碼。如何使用 J2EE 中之 Entity Bean 的範例： // J2EE EJB Example try { // lookup the User home interface UserHome userHome = (UserHome)context.lookup(User.class); // find the User remote interface User = userHome.findByPrimaryKey(new UserKey(userNameField)); ... } catch (Exception e) { ... } 建議的 Java 工具N/A參照https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.htmlhttps://docs.oracle.com/javase/7/docs/api/java/sql/CallableStatement.html** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但必須利用 Servlet，在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是在 \"Validator\" 公用程式類別中將上述常式當作靜態方法來實作。下列各節說明範例驗證器類別[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // Java example to validate required fields public Class Validator { ... public static boolean validateRequired(String value) { boolean isFieldValid = false; if (value != null &amp;&amp; value.trim().length() &gt; 0) { isFieldValid = true; } return isFieldValid; } ... } ... String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateRequired(fieldValue)) { // fieldValue is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。請利用 Java 基本封套類別來檢查欄位值是否能安全轉換成所需要的基本資料類型。如何驗證數值欄位（int 類型）的範例： // Java example to validate that a field is an int number public Class Validator { ... public static boolean validateInt(String value) { boolean isFieldValid = false; try { Integer.parseInt(value); isFieldValid = true; } catch (Exception e) { isFieldValid = false; } return isFieldValid; } ... } ... // check if the HTTP request parameter is of type int String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // fieldValue is valid, continue processing request ... } 在實務中，好的做法是將所有 HTTP 要求參數轉換成它們的相關資料類型。例如，開發人員應該將要求參數的 \"integerValue\" 儲存在要求屬性中，再依照下列範例所示來使用它： // Example to convert the HTTP request parameter to a primitive wrapper data type // and store this value in a request attribute for further processing String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // convert fieldValue to an Integer Integer integerValue = Integer.getInteger(fieldValue); // store integerValue in a request attribute request.setAttribute(\"fieldName\", integerValue); } ... // Use the request attribute for further processing Integer integerValue = (Integer)request.getAttribute(\"fieldName\"); ... 應用程式應該處理的主要 Java 資料類型：- Byte- Short- Integer- Long- Float- Double- Date[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。驗證 userName 欄位的長度是否在 8-20 個字元之間的範例： // Example to validate the field length public Class Validator { ... public static boolean validateLength(String value, int minLength, int maxLength) { String validatedValue = value; if (!validateRequired(value)) { validatedValue = \"\"; } return (validatedValue.length() &gt;= minLength &amp;&amp; validatedValue.length() &lt;= maxLength); } ... } ... String userName = request.getParameter(\"userName\"); if (Validator.validateRequired(userName)) { if (Validator.validateLength(userName, 8, 20)) { // userName is valid, continue further processing ... } } [4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。驗證輸入 numberOfChoices 是否在 10-20 之間的範例： // Example to validate the field range public Class Validator { ... public static boolean validateRange(int value, int min, int max) { return (value &gt;= min &amp;&amp; value &lt;= max); } ... } ... String fieldValue = request.getParameter(\"numberOfChoices\"); if (Validator.validateRequired(fieldValue)) { if (Validator.validateInt(fieldValue)) { int numberOfChoices = Integer.parseInt(fieldValue); if (Validator.validateRange(numberOfChoices, 10, 20)) { // numberOfChoices is valid, continue processing request ... } } } [5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。請一律對照函數需求所定義容許的選項來驗證所選的使用者值。對照容許的選項清單來驗證使用者選項的範例： // Example to validate user selection against a list of options public Class Validator { ... public static boolean validateOption(Object[] options, Object value) { boolean isValidValue = false; try { List list = Arrays.asList(options); if (list != null) { isValidValue = list.contains(value); } } catch (Exception e) { } return isValidValue; } ... } ... // Allowed options String[] options = {\"option1\", \"option2\", \"option3\"); // Verify that the user selection is one of the allowed options String userSelection = request.getParameter(\"userSelection\"); if (Validator.validateOption(options, userSelection)) { // valid user selection, continue processing request ... } [6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]*$Java 1.3 或更早的版本不包括任何正規表示式套件。建議搭配 Java 1.3 來使用「Apache 正規表示式套件」（請參閱下列「資源」），以解決這項支援欠缺。執行正規表示式驗證的範例： // Example to validate that a given value matches a specified pattern // using the Apache regular expression package import org.apache.regexp.RE; import org.apache.regexp.RESyntaxException; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { RE r = new RE(expression); match = r.match(value); } return match; } ... } ... // Verify that the userName request parameter is alpha-numeric String userName = request.getParameter(\"userName\"); if (Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { // userName is valid, continue processing request ... } Java 1.4 引進了新的正規表示式套件 (java.util.regex)。以下是 Validator.matchPattern 的修正版，使用新的 Java 1.4 正規表示式套件： // Example to validate that a given value matches a specified pattern // using the Java 1.4 regular expression package import java.util.regex.Pattern; import java.util.regexe.Matcher; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { match = Pattern.matches(expression, value); } return match; } ... } [7] Cookie 值請利用 javax.servlet.http.Cookie 物件來驗證 Cookie 值。依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。驗證必要 Cookie 值的範例： // Example to validate a required cookie value // First retrieve all available cookies submitted in the HTTP request Cookie[] cookies = request.getCookies(); if (cookies != null) { // find the \"user\" cookie for (int i=0; i&lt;cookies.length; ++i) { if (cookies[i].getName().equals(\"user\")) { // validate the cookie value if (Validator.validateRequired(cookies[i].getValue()) { // valid cookie value, continue processing request ... } } } } [8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，請將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +將機密字元轉換成對應的字元實體來過濾指定字串的範例： // Example to filter sensitive data to prevent cross-site scripting public Class Validator { ... public static String filter(String value) { if (value == null) { return null; } StringBuffer result = new StringBuffer(value.length()); for (int i=0; i&lt;value.length(); ++i) { switch (value.charAt(i)) { case '&lt;': result.append(\"&lt;\"); break; case '&gt;': result.append(\"&gt;\"); break; case '\"': result.append(\"\"\"); break; case '\\'': result.append(\"'\"); break; case '%': result.append(\"%\"); break; case ';': result.append(\";\"); break; case '(': result.append(\"(\"); break; case ')': result.append(\")\"); break; case '&amp;': result.append(\"&amp;\"); break; case '+': result.append(\"+\"); break; default: result.append(value.charAt(i)); break; } return result; } ... } ... // Filter the HTTP response using Validator.filter PrintWriter out = response.getWriter(); // set output response out.write(Validator.filter(response)); out.close(); Java Servlet API 2.3 引進了「過濾器」，它支援截取及轉換 HTTP 要求或回應。利用「Servlet 過濾器」，以 Validator.filter 來消毒回應的範例： // Example to filter all sensitive characters in the HTTP response using a Java Filter. // This example is for illustration purposes since it will filter all content in the response, including HTML tags! public class SensitiveCharsFilter implements Filter { ... public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { PrintWriter out = response.getWriter(); ResponseWrapper wrapper = new ResponseWrapper((HttpServletResponse)response); chain.doFilter(request, wrapper); CharArrayWriter caw = new CharArrayWriter(); caw.write(Validator.filter(wrapper.toString())); response.setContentType(\"text/html\"); response.setContentLength(caw.toString().length()); out.write(caw.toString()); out.close(); } ... public class CharResponseWrapper extends HttpServletResponseWrapper { private CharArrayWriter output; public String toString() { return output.toString(); } public CharResponseWrapper(HttpServletResponse response){ super(response); output = new CharArrayWriter(); } public PrintWriter getWriter(){ return new PrintWriter(output); } } } } [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，請務必利用 Cookie.setSecure（布林旗標），在 HTTP 回應中設定 Cookie 的安全旗標，以指示瀏覽器利用 HTTPS 或 SSL 之類的安全通訊協定來傳送 Cookie。維護 \"user\" Cookie 安全的範例： // Example to secure a cookie, i.e. instruct the browser to // send the cookie using a secure protocol Cookie cookie = new Cookie(\"user\", \"sensitive\"); cookie.setSecure(true); response.addCookie(cookie); 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」實作上述所有資料驗證需求，是一個功能強大的架構。這些規則配置在定義表單欄位輸入驗證規則的 XML 檔中。依預設，Struts 支援在利用 Struts 'bean:write' 標籤撰寫的所有資料上，過濾 [8] HTTP 回應中輸出的危險字元。設定 'filter=false' 旗標可以停用這個過濾。Struts 定義下列基本輸入驗證器，但也可以定義自訂驗證器：required：如果欄位含有空格以外的任何字元，便告成功。mask：如果值符合 mask 屬性給定的正規表示式，便告成功。range：如果值在 min 和 max 屬性給定的值範圍內（(value &gt;= min) 且 (value &lt;= max)），便告成功。maxLength：如果欄位長度小於或等於 max 屬性，便告成功。minLength：如果欄位長度大於或等於 min 屬性，便告成功。byte、short、integer、long、float、double：如果值可以轉換成對應的基本類型，便告成功。date：如果值代表有效日期，便告成功。可提供日期型樣。creditCard：如果值可能是有效的信用卡號碼，便告成功。e-mail：如果值可能是有效的電子郵件位址，便告成功。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件及輸入驗證的 Java API (JSR 127)。JavaServer Faces API 實作下列基本驗證器，但可以定義自訂驗證器：validate_doublerange：登錄元件的 DoubleRangeValidatorvalidate_length：登錄元件的 LengthValidatorvalidate_longrange：登錄元件的 LongRangeValidatorvalidate_required：登錄元件的 RequiredValidatorvalidate_stringrange：登錄元件的 StringRangeValidatorvalidator：登錄元件的自訂 ValidatorJavaServer Faces API 定義下列 UIInput 和 UIOutput 展現器（標籤）：input_date：接受以 java.text.Date 實例格式化的 java.util.Dateoutput_date：顯示以 java.text.Date 實例格式化的 java.util.Dateinput_datetime：接受以 java.text.Time 實例格式化的 java.util.Dateoutput_datetime：顯示以 java.text.Time 實例格式化的 java.util.Dateinput_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）output_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）input_text：接受單行字串。output_text：顯示單行字串。input_time：接受以 java.text.DateFormat 時間實例格式化的 java.util.Dateoutput_time：顯示以 java.text.DateFormat 時間實例格式化的 java.util.Dateinput_hidden：可讓頁面作者將隱藏變數併入頁面input_secret：接受不含空格的單行文字，輸入之時，將它顯示成一組星號input_textarea：接受多行文字output_errors：顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息output_label：將巢狀元件顯示為指定輸入欄位的標籤output_message：顯示本地化訊息利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 錯誤處理：許多 J2EE Web 應用程式架構都遵循「模型視圖控制器 (MVC)」型樣。在這個型樣中，Servlet 扮演控制器的角色。Servlet 將應用程式處理程序委派給 JavaBean，例如，EJB Session Bean（模型）。之後，Servlet 再將要求轉遞給 JSP（視圖）來呈現處理結果。Servlet 應該檢查所有輸入、輸出、回覆碼、錯誤碼及已知的異常狀況，以確保會實際進行預期的處理程序。資料驗證可以保護應用程式免於遭受惡意的資料竄改，有效的錯誤處理策略則是防止應用程式意外揭露內部錯誤訊息（例如：異常狀況堆疊追蹤）所不可或缺。好的錯誤處理策略會處理下列項目：[1] 定義錯誤[2] 報告錯誤[3] 呈現錯誤[4] 錯誤對映[1] 定義錯誤應該避免將錯誤訊息寫在應用程式層（例如：Servlet）。相反地，應用程式應該使用對映至已知之應用程式失敗的錯誤索引鍵。在實務中，好的做法是定義錯誤索引鍵來對映至 HTML 表單欄位或其他 Bean 內容的驗證規則。比方說，如果需要 \"user_name\" 欄位，它必須是英數字元，且在資料庫中必須是唯一，便應該定義下列錯誤索引鍵：(a) ERROR_USERNAME_REQUIRED：這個錯誤索引鍵用來顯示一則訊息，通知使用者需要 \"user_name\" 欄位；(b) ERROR_USERNAME_ALPHANUMERIC：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 欄位應該是英數字元；(c) ERROR_USERNAME_DUPLICATE：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 值在資料庫中重複；(d) ERROR_USERNAME_INVALID：這個錯誤索引鍵用來顯示一則一般訊息，通知使用者 \"user_name\" 值無效；在實務中，好的做法是定義下列架構 Java 類別來儲存及報告應用程式錯誤：- ErrorKeys：定義所有錯誤索引鍵 // Example: ErrorKeys defining the following error keys: // - ERROR_USERNAME_REQUIRED // - ERROR_USERNAME_ALPHANUMERIC // - ERROR_USERNAME_DUPLICATE // - ERROR_USERNAME_INVALID // ... public Class ErrorKeys { public static final String ERROR_USERNAME_REQUIRED = \"error.username.required\"; public static final String ERROR_USERNAME_ALPHANUMERIC = \"error.username.alphanumeric\"; public static final String ERROR_USERNAME_DUPLICATE = \"error.username.duplicate\"; public static final String ERROR_USERNAME_INVALID = \"error.username.invalid\"; ... } - Error：封裝個別錯誤 // Example: Error encapsulates an error key. // Error is serializable to support code executing in multiple JVMs. public Class Error implements Serializable { // Constructor given a specified error key public Error(String key) { this(key, null); } // Constructor given a specified error key and array of placeholder objects public Error(String key, Object[] values) { this.key = key; this.values = values; } // Returns the error key public String getKey() { return this.key; } // Returns the placeholder values public Object[] getValues() { return this.values; } private String key = null; private Object[] values = null; } - Errors：封裝錯誤的集合 // Example: Errors encapsulates the Error objects being reported to the presentation layer. // Errors are stored in a HashMap where the key is the bean property name and value is an // ArrayList of Error objects. public Class Errors implements Serializable { // Adds an Error object to the Collection of errors for the specified bean property. public void addError(String property, Error error) { ArrayList propertyErrors = (ArrayList)errors.get(property); if (propertyErrors == null) { propertyErrors = new ArrayList(); errors.put(property, propertyErrors); } propertyErrors.put(error); } // Returns true if there are any errors public boolean hasErrors() { return (errors.size &gt; 0); } // Returns the Errors for the specified property public ArrayList getErrors(String property) { return (ArrayList)errors.get(property); } private HashMap errors = new HashMap(); } 以下是利用上述架構類別來處理 \"user_name\" 欄位驗證錯誤的範例： // Example to process validation errors of the \"user_name\" field. Errors errors = new Errors(); String userName = request.getParameter(\"user_name\"); // (a) Required validation rule if (!Validator.validateRequired(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_REQUIRED)); } // (b) Alpha-numeric validation rule else if (!Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_ALPHANUMERIC)); } else { // (c) Duplicate check validation rule // We assume that there is an existing UserValidationEJB session bean that implements // a checkIfDuplicate() method to verify if the user already exists in the database. try { ... if (UserValidationEJB.checkIfDuplicate(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE)); } } catch (RemoteException e) { // log the error logger.error(\"Could not validate user for specified userName: \" + userName); errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE); } } // set the errors object in a request attribute called \"errors\" request.setAttribute(\"errors\", errors); ... [2] 報告錯誤報告 Web 層應用程式錯誤的方式有兩種：(a) Servlet 錯誤機制(b) JSP 錯誤機制[2-a] Servlet 錯誤機制Servlet 報告錯誤的可能方式如下：- 轉遞至輸入 JSP（已將錯誤儲存在要求屬性中），或- 利用 HTTP 錯誤碼引數來呼叫 response.sendError，或- 擲出異常狀況在實務中，好的做法是處理所有已知的應用程式錯誤（依照 [1] 區段所說明），將它們儲存在要求屬性中，再轉遞給輸入 JSP。輸入 JSP 應該顯示錯誤訊息，並提示使用者重新輸入資料。下列範例說明如何轉遞到輸入 JSP (userInput.jsp)： // Example to forward to the userInput.jsp following user validation errors RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd != null) { rd.forward(request, response); } 如果 Servlet 無法轉遞到已知的 JSP 頁面，第二個選項是利用 response.sendError 方法，設定 HttpServletResponse.SC_INTERNAL_SERVER_ERROR 引數（狀態碼 500）來報告錯誤。請參閱 javax.servlet.http.HttpServletResponse javadoc，以取得各種 HTTP 狀態碼的詳細資訊。傳回 HTTP 錯誤的範例： // Example to return a HTTP error code RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd == null) { // messages is a resource bundle with all message keys and values response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, messages.getMessage(ErrorKeys.ERROR_USERNAME_INVALID)); } 作為最後的手段，Servlet 可以擲出異常狀況，它必須是下列類別之一的子類別：- RuntimeException- ServletException- IOException[2-b] JSP 錯誤機制 JSP 頁面依照下列範例所示來定義 errorPage 指引，從而提供了執行時期異常狀況的處理機制： &lt;%@ page errorPage=\"/errors/userValidation.jsp\" %&gt; 未捕捉的 JSP 異常狀況是轉遞到指定的 errorPage，而原始異常狀況則設在稱為 javax.servlet.jsp.jspException 的要求參數中。錯誤頁面必須包含 isErrorPage 指引，如下所示： &lt;%@ page isErrorPage=\"true\" %&gt; isErrorPage 指引會使 \"exception\" 變數起始設定為所擲出的異常狀況物件。[3] 呈現錯誤J2SE Internationalization API 提供用來提出應用程式資源以及將訊息格式化的公用程式類別，其中包括：(a) 資源組(b) 訊息格式化[3-a] 資源組資源組會將本地化的資料與使用它的原始碼分開，從而支援國際化。每個資源組都會儲存特定語言環境之鍵值配對的對映。通常是利用或延伸 java.util.PropertyResourceBundle，它會將內容儲存在外部內容檔中，如下列範例所示： ################################################ # ErrorMessages.properties ################################################ # required user name error message error.username.required=User name field is required # invalid user name format error.username.alphanumeric=User name must be alphanumeric # duplicate user name error message error.username.duplicate=User name {0} already exists, please choose another one ... 定義多重資源可以支援不同的語言環境（因此稱為資源組）。例如，定義 ErrorMessages_fr.properties 可以支援資源組系列的法國成員。如果要求之語言環境的資源成員不存在，便會使用預設成員。在上述範例中，預設資源是 ErrorMessages.properties。依使用者的語言環境而定，應用程式（JSP 或 Servlet）會從適當的資源擷取內容。[3-b] 訊息格式化J2SE 標準類別 java.util.MessageFormat 提供以取代位置保留元來建立訊息的一般方式。MessageFormat 物件包含內嵌了格式指定元的型樣字串，如下所示： // Example to show how to format a message using placeholder parameters String pattern = \"User name {0} already exists, please choose another one\"; String userName = request.getParameter(\"user_name\"); Object[] args = new Object[1]; args[0] = userName; String message = MessageFormat.format(pattern, args); 以下是利用 ResourceBundle 和 MessageFormat 來呈現錯誤訊息的更綜合性的範例： // Example to render an error message from a localized ErrorMessages resource (properties file) // Utility class to retrieve locale-specific error messages public Class ErrorMessageResource { // Returns the error message for the specified error key in the environment locale public String getErrorMessage(String errorKey) { return getErrorMessage(errorKey, defaultLocale); } // Returns the error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Locale locale) { return getErrorMessage(errorKey, null, locale); } // Returns a formatted error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Object[] args, Locale locale) { // Get localized ErrorMessageResource ResourceBundle errorMessageResource = ResourceBundle.getBundle(\"ErrorMessages\", locale); // Get localized error message String errorMessage = errorMessageResource.getString(errorKey); if (args != null) { // Format the message using the specified placeholders args return MessageFormat.format(errorMessage, args); } else { return errorMessage; } } // default environment locale private Locale defaultLocale = Locale.getDefaultLocale(); } ... // Get the user's locale Locale userLocale = request.getLocale(); // Check if there were any validation errors Errors errors = (Errors)request.getAttribute(\"errors\"); if (errors != null &amp;&amp; errors.hasErrors()) { // iterate through errors and output error messages corresponding to the \"user_name\" property ArrayList userNameErrors = errors.getErrors(\"user_name\"); ListIterator iterator = userNameErrors.iterator(); while (iterator.hasNext()) { // Get the next error object Error error = (Error)iterator.next(); String errorMessage = ErrorMessageResource.getErrorMessage(error.getKey(), userLocale); output.write(errorMessage + \"\\r\\n\"); } } 建議您定義自訂 JSP 標籤（如 displayErrors）來疊代處理及呈現錯誤訊息，如上述範例所示。[4] 錯誤對映一般而言，「Servlet 儲存器」會傳回對應於回應狀態碼或異常狀況的預設錯誤頁面。您可以利用自訂錯誤頁面來指定狀態碼或異常狀況與 Web 資源之間的對映。在實務中，好的做法是開發不揭露內部錯誤狀態的靜態錯誤頁面（依預設，大部分 Servlet 儲存器都會報告內部錯誤訊息）。這項對映是依照下列範例所指定，配置在「Web 部署描述子 (web.xml)」中： &lt;!-- Mapping of HTTP error codes and application exceptions to error pages --&gt; &lt;error-page&gt; &lt;exception-type&gt;UserValidationException&lt;/exception-type&gt; &lt;location&gt;/errors/validationError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/exception-type&gt; &lt;location&gt;/errors/internalError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; ... &lt;/error-page&gt; ... 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」是依照上述說明來定義錯誤處理機制的 Java 架構。驗證規則配置在 XML 檔中，檔案定義了表單欄位的輸入驗證規則以及對應的驗證錯誤索引鍵。Struts 提供國際化支援，供您利用資源組和訊息格式化來建置本地化應用程式。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; Struts JSP 標籤庫定義了有條件地顯示一組累計錯誤訊息的 \"errors\" 標籤，如下列範例所示： &lt;%@ page language=\"java\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-html.tld\" prefix=\"html\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-bean.tld\" prefix=\"bean\" %&gt; &lt;html:html&gt; &lt;head&gt; &lt;body&gt; &lt;html:form action=\"/logon.do\"&gt; &lt;table border=\"0\" width=\"100%\"&gt; &lt;tr&gt; &lt;th align=\"right\"&gt; &lt;html:errors property=\"username\"/&gt; &lt;bean:message key=\"prompt.username\"/&gt; &lt;/th&gt; &lt;td align=\"left\"&gt; &lt;html:text property=\"username\" size=\"16\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt; &lt;html:submit&gt;&lt;bean:message key=\"button.submit\"/&gt;&lt;/html:submit&gt; &lt;/td&gt; &lt;td align=\"right\"&gt; &lt;html:reset&gt;&lt;bean:message key=\"button.reset\"/&gt;&lt;/html:reset&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/html:form&gt; &lt;/body&gt; &lt;/html:html&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件、驗證輸入，以及支援國際化的 Java API (JSR 127)。JavaServer Faces API 定義了 \"output_errors\" UIOutput 展現器，以顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息。利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 過濾使用者輸入將任何資料傳給 SQL 查詢之前，一律應該先利用白名單技術來適當過濾。這無論如何強調都不為過。過濾使用者輸入可讓許多注入缺失，在抵達資料庫之前便得到更正。** 引用使用者輸入不論任何資料類型，只要資料庫允許，便用單引號括住所有使用者資料，始終是好的觀念。MySQL 接受這個格式化技術。** 跳出資料值如果您使用 MySQL 4.3.0 或更新的版本，您應該用 mysql_real_escape_string() 來跳出所有字串。如果使用舊版的 MySQL，便應該使用 mysql_escape_string() 函數。如果未使用 MySQL，您可以選擇使用特定資料庫的特定跳出函數。如果不知道跳出函數，您可以選擇使用較一般的跳出函數，例如，addslashes()。如果使用 PEAR DB 資料庫抽象層，您可以使用 DB::quote() 方法或使用 ? 之類的查詢位置保留元，它會自動跳出取代位置保留元的值。參照http://ca3.php.net/mysql_real_escape_stringhttp://ca.php.net/mysql_escape_stringhttp://ca.php.net/addslasheshttp://pear.php.net/package-info.php?package=DB** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但一律必須在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是實作一或多個驗證各個應用程式參數的函數。下列各節說明一些檢查範例。[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // PHP example to validate required fields function validateRequired($input) { ... $pass = false; if (strlen(trim($input))&gt;0){ $pass = true; } return $pass; ... } ... if (validateRequired($fieldName)) { // fieldName is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。[4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。[5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。請一律對照函數需求所定義容許的選項來驗證所選的使用者值。[6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]+$[7] Cookie 值依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。[8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，開發人員應該將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +PHP 包括一些 htmlentities() 之類的自動化消毒公用程式函數： $input = htmlentities($input, ENT_QUOTES, 'UTF-8'); 此外，為了避免「跨網站指令碼」的 UTF-7 變式，您應該明確定義回應的 Content-Type 標頭，例如： &lt;?php header('Content-Type: text/html; charset=UTF-8'); ?&gt; [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，且透過 SSL 來傳輸它時，請務必先在 HTTP 回應中設定 Cookie 的安全旗標。這會指示瀏覽器只透過 SSL 連線來使用這個 Cookie。您可以利用下列程式碼範例來維護 Cookie 安全： &lt;$php $value = \"some_value\"; $time = time()+3600; $path = \"/application/\"; $domain = \".example.com\"; $secure = 1; setcookie(\"CookieName\", $value, $time, $path, $domain, $secure, TRUE); ?&gt; 此外，我們建議您使用 HttpOnly 旗標。當 HttpOnly 旗標設為 TRUE 時，只能透過 HTTP 通訊協定來存取 Cookie。這表示無法用 JavaScript 之類的 Scripting 語言存取 Cookie。這個設定有助於實際減少透過 XSS 攻擊來盜用身分的情況（不過，並非所有瀏覽器都支援）。PHP 5.2.0 新增 HttpOnly 旗標。參照[1] 利用「HTTP 專用 Cookie」緩和「跨網站指令碼」： http://msdn2.microsoft.com/en-us/library/ms533046.aspx[2] PHP 安全聯盟： http://phpsec.org/[3] PHP &amp; Web 應用程式安全部落格 (Chris Shiflett)： http://shiflett.org/<w:br w:type=\"page\"/>"
        },
        {
            "name": "盲目的 SQL 注入",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "嚴重",
            "cvss": "9.4",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/showthread.asp",
            "entity": "id (Parameter)",
            "risk": "有可能檢視、修改或刪除資料庫項目和表格\n",
            "cause": "未正確地消毒使用者所輸入的危險字元",
            "solution": "檢查危險字元注入可能的解決方案",
            "mark": "id=0%2B0%2B0%2B0\nid=12345%2B12345%2B0\nid=12345-1234-0\nid=12345-12345%2B0",
            "solution_description": "有可能檢視、修改或刪除資料庫項目和表格軟體會使用受外部影響的輸入來建構所有或部分 SQL 指令，但是在傳送至資料庫時，其無法使可修改 SQL 指令的元素失效。如果未針對可由使用者控制的輸入進行充分移除或加引號，其所產生的 SQL 查詢可能會造成這些輸入被解譯為 SQL 而非一般使用者資料。這可能會被用來改變查詢邏輯以略過安全檢查，或插入其他陳述式以修改後端資料庫，其中可能包括執行系統指令。例如，假設有一個 HTML 頁面含有登入表單，最終會使用使用者輸入對資料庫執行下列 SQL 查詢： SELECT * FROM accounts WHERE username='$user' AND password='$pass' $user 和 $pass 這兩個變數包含使用者在登入表單中所輸入的使用者認證。如果使用者輸入 \"jsmith\" 作為使用者名稱，且輸入 \"Demo1234\" 作為密碼，則 SQL 查詢會看起來如下： SELECT * FROM accounts WHERE username='jsmith' AND password='Demo1234' 但是，如果使用者輸入 \"'\"（一個單引號）作為使用者名稱，且輸入 \"'\"（一個單引號）作為密碼，則 SQL 查詢會看起來如下： SELECT * FROM accounts WHERE username=''' AND password=''' 這當然是形態異常的 SQL 查詢，且會呼叫可能在 HTTP 回應中傳回的錯誤訊息。這類錯誤會通知攻擊者 SQL 注入已成功，而會引導攻擊者嘗試進一步攻擊手法。「盲目的 SQL 注入」與「SQL 注入」類似。差異在於運用它，攻擊者不需尋找回應中的 SQL 錯誤。因此，AppScan 用來識別它的方法也不同。AppScan 不會嘗試呼叫 SQL 錯誤，而是透過多項要求來操作應用程式的邏輯，以找出很容易遭到 SQL 注入攻擊的 Script。這項技術需要傳送有弱點的參數（被內嵌在 SQL 查詢中的參數）已遭修改的要求，使得回應能夠指出是否在 SQL 查詢環境定義中使用資料。這項修改包括搭配原始字串來使用 AND 布林表示式，使它一時得出 True 一時得出 False。在一個情況中，最後結果應該與原始結果相同（登入成功）；在另一情況中，結果應該明顯不同（登入失敗）。在某些少見的情況中，得出 True 的 OR 表示式也很有用。如果原始資料是數值，就可以採用較簡單的技巧。假設原始資料是 123。這項資料可以在某項要求中取代為 0+123，在另一項要求中取代為 456+123。第一項要求的結果應該與原始結果相同，第二項要求的結果應該不同（因為得出的數字是 579）。在某些情況中，我們仍需要上面所說明的攻擊版本（使用 AND 和 OR），但並不跳出字串上下文。「盲目的 SQL 注入」背後的概念是，即使未直接收到資料庫的資料（以錯誤訊息或洩漏資訊的形式），也可能擷取資料庫中的資料（每次一個位元），或以惡意方式修改查詢。觀念在於，應用程式的行為（傳回的回應與原始回應相同或不同）可以提供關於所評估（已修改）查詢的單一位元資訊，也就是說，攻擊者有可能規劃使用 SQL 布林表示式，並以應用程式行為（相同/不同於原始行為）的形式來侵害其評估（單一位元）。",
            "solution_suggest": "以下是幾種減輕風險的技巧：[1] 策略：程式庫或架構使用檢查過且不容許此弱點的程式庫或架構，或提供使其更容易避免的建構項。[2] 策略：參數化如果可行，請使用結構化機制來自動強制分開資料與程式碼。這些機制可能可以自動提供相關的引用、編碼和驗證，而不是在每次產生輸出時，都依賴開發人員來提供。[3] 策略：環境強化 使用完成必要作業所需的最低專用權，來執行程式碼。[4] 策略：輸出編碼如果儘管有風險，您還是需要使用動態產生的查詢字串或指令，適當地括住引數且避免在這些引數內使用任何特殊字元。[5] 策略：輸入驗證假設所有輸入都是惡意的。請使用「接受已知良好」輸入驗證策略：嚴格符合規格的可接受輸入白名單。拒絕未嚴格符合規格的任何輸入，或將其轉換成嚴格符合規格者。請勿只靠使用黑名單來偵測惡意或形態異常的輸入。不過，在偵測潛在攻擊或判斷哪些輸入因形態異常而應該斷然拒絕時，黑名單就很有用。以下是保護 Web 應用程式免於遭受 SQL 注入攻擊的兩種可能方式：[1] 使用儲存程序，而不用動態建置的 SQL 查詢字串。參數傳給 SQL Server 儲存程序的方式，會防止使用單引號和連字號。如何在 ASP.NET 中使用儲存程序的範例如下： ' Visual Basic example Dim DS As DataSet Dim MyConnection As SqlConnection Dim MyCommand As SqlDataAdapter Dim SelectCommand As String = \"select * from users where username = @username\" ... MyCommand.SelectCommand.Parameters.Add(New SqlParameter(\"@username\", SqlDbType.NVarChar, 20)) MyCommand.SelectCommand.Parameters(\"@username\").Value = UserNameField.Value // C# example String selectCmd = \"select * from Authors where state = @username\"; SqlConnection myConnection = new SqlConnection(\"server=...\"); SqlDataAdapter myCommand = new SqlDataAdapter(selectCmd, myConnection); myCommand.SelectCommand.Parameters.Add(new SqlParameter(\"@username\", SqlDbType.NVarChar, 20)); myCommand.SelectCommand.Parameters[\"@username\"].Value = UserNameField.Value; [2] 您可以利用驗證控制項，將輸入驗證新增到「Web 表單」頁面中。驗證控制項提供適用於標準驗證之所有一般類型的簡易使用機制（例如：測試日期是否有效，或值是否在範圍內），以及用來提供自訂編寫驗證的方式。此外，驗證控制項也可讓您完整自訂向使用者顯示錯誤資訊的方式。驗證控制項可以搭配「Web 表單」頁面類別檔所處理的任何控制項來使用，其中包括 HTML 和 Web 伺服器控制項。如果要確定使用者輸入只包含有效值，您可以使用下列其中一個驗證控制項：a. \"RangeValidator\"：檢查使用者的輸入（值）是否在指定的上下界限之間。您可以檢查數字、英文字母和日期之配對內的範圍。b. \"RegularExpressionValidator\"：檢查輸入是否符合正規表示式所定義的型樣。這類型的驗證可讓您檢查可預期的字元序列，例如：社會保險號碼、電子郵件位址、電話號碼、郵遞區號等等中的字元序列。重要注意事項：驗證控制項不會封鎖使用者輸入，或變更頁面處理流程；它們只會設定錯誤狀態，以及產生錯誤訊息。在執行進一步的應用程式專屬動作之前，程式設計師負責測試程式碼中的控制項狀態。檢查使用者輸入有效性有兩種方式：1. 測試一般錯誤狀態：在您的程式碼中，測試頁面的 IsValid 內容。這個內容會累積頁面上所有驗證控制項的 IsValid 內容值（使用邏輯 AND）。如果其中一個驗證控制項設為無效，頁面內容便會傳回 False。2. 測試個別控制項的錯誤狀態：在迴圈中處理頁面的驗證器集合，集合中含有指向所有驗證控制項的參照。之後，您便可以檢查每個驗證控制項的 IsValid 內容。** 備妥陳述式：保護您的應用程式免於遭受 SQL 注入（亦即，惡意竄改 SQL 參數）有三種可能的方式。請利用下列方式，而非動態建置 SQL 陳述式：[1] PreparedStatement，經過前置編譯而存放在 PreparedStatement 物件儲存區中。PreparedStatement 定義用來登錄輸入參數的設定元，輸入參數相容於支援的 JDBC SQL 資料類型。例如，setString 應該用於 VARCHAR 或 LONGVARCHAR 類型的輸入參數（請參閱 Java API，以取得進一步的詳細資料）。這個設定輸入參數的方式，可以防止攻擊者注入不正確的字元（如單引號）來操作 SQL 陳述式。如何使用 J2EE 中之 PreparedStatement 的範例： // J2EE PreparedStatemenet Example // Get a connection to the database Connection myConnection; if (isDataSourceEnabled()) { // using the DataSource to get a managed connection Context ctx = new InitialContext(); myConnection = ((DataSource)ctx.lookup(datasourceName)).getConnection(dbUserName, dbPassword); } else { try { // using the DriverManager to get a JDBC connection Class.forName(jdbcDriverClassPath); myConnection = DriverManager.getConnection(jdbcURL, dbUserName, dbPassword); } catch (ClassNotFoundException e) { ... } } ... try { PreparedStatement myStatement = myConnection.prepareStatement(\"select * from users where username = ?\"); myStatement.setString(1, userNameField); ResultSet rs = myStatement.executeQuery(); ... rs.close(); } catch (SQLException sqlException) { ... } finally { myStatement.close(); myConnection.close(); } [2] CallableStatement，延伸 PreparedStatement 來執行資料庫 SQL 儲存程序。這個類別繼承 PreparedStatement 的輸入設定元（請參閱上面的 [1]）。下列範例假設已建立好這個資料庫儲存程序：CREATE PROCEDURE select_user (@username varchar(20))AS SELECT * FROM USERS WHERE USERNAME = @username;如何利用 J2EE 中的 CallableStatement 來執行上述儲存程序的範例： // J2EE PreparedStatemenet Example // Get a connection to the database Connection myConnection; if (isDataSourceEnabled()) { // using the DataSource to get a managed connection Context ctx = new InitialContext(); myConnection = ((DataSource)ctx.lookup(datasourceName)).getConnection(dbUserName, dbPassword); } else { try { // using the DriverManager to get a JDBC connection Class.forName(jdbcDriverClassPath); myConnection = DriverManager.getConnection(jdbcURL, dbUserName, dbPassword); } catch (ClassNotFoundException e) { ... } } ... try { PreparedStatement myStatement = myConnection.prepareCall(\"{?= call select_user ?,?}\"); myStatement.setString(1, userNameField); myStatement.registerOutParameter(1, Types.VARCHAR); ResultSet rs = myStatement.executeQuery(); ... rs.close(); } catch (SQLException sqlException) { ... } finally { myStatement.close(); myConnection.close(); } [3] Entity Bean，在持續性儲存庫機制中代表 EJB 商業物件。Entity Bean 有兩種類型：Bean 管理和儲存器管理。當使用 Bean 管理的持續性時，開發人員負責撰寫存取資料庫的 SQL 程式碼（請參閱上述 [1] 和 [2] 區段）。當使用儲存器管理的持續性時，EJB 儲存器會自動產生 SQL 程式碼。因此，儲存器要負責防止惡意嘗試竄改產生的 SQL 程式碼。如何使用 J2EE 中之 Entity Bean 的範例： // J2EE EJB Example try { // lookup the User home interface UserHome userHome = (UserHome)context.lookup(User.class); // find the User remote interface User = userHome.findByPrimaryKey(new UserKey(userNameField)); ... } catch (Exception e) { ... } 建議的 Java 工具N/A參照https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.htmlhttps://docs.oracle.com/javase/7/docs/api/java/sql/CallableStatement.html** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但必須利用 Servlet，在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是在 \"Validator\" 公用程式類別中將上述常式當作靜態方法來實作。下列各節說明範例驗證器類別[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // Java example to validate required fields public Class Validator { ... public static boolean validateRequired(String value) { boolean isFieldValid = false; if (value != null &amp;&amp; value.trim().length() &gt; 0) { isFieldValid = true; } return isFieldValid; } ... } ... String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateRequired(fieldValue)) { // fieldValue is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。請利用 Java 基本封套類別來檢查欄位值是否能安全轉換成所需要的基本資料類型。如何驗證數值欄位（int 類型）的範例： // Java example to validate that a field is an int number public Class Validator { ... public static boolean validateInt(String value) { boolean isFieldValid = false; try { Integer.parseInt(value); isFieldValid = true; } catch (Exception e) { isFieldValid = false; } return isFieldValid; } ... } ... // check if the HTTP request parameter is of type int String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // fieldValue is valid, continue processing request ... } 在實務中，好的做法是將所有 HTTP 要求參數轉換成它們的相關資料類型。例如，開發人員應該將要求參數的 \"integerValue\" 儲存在要求屬性中，再依照下列範例所示來使用它： // Example to convert the HTTP request parameter to a primitive wrapper data type // and store this value in a request attribute for further processing String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // convert fieldValue to an Integer Integer integerValue = Integer.getInteger(fieldValue); // store integerValue in a request attribute request.setAttribute(\"fieldName\", integerValue); } ... // Use the request attribute for further processing Integer integerValue = (Integer)request.getAttribute(\"fieldName\"); ... 應用程式應該處理的主要 Java 資料類型：- Byte- Short- Integer- Long- Float- Double- Date[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。驗證 userName 欄位的長度是否在 8-20 個字元之間的範例： // Example to validate the field length public Class Validator { ... public static boolean validateLength(String value, int minLength, int maxLength) { String validatedValue = value; if (!validateRequired(value)) { validatedValue = \"\"; } return (validatedValue.length() &gt;= minLength &amp;&amp; validatedValue.length() &lt;= maxLength); } ... } ... String userName = request.getParameter(\"userName\"); if (Validator.validateRequired(userName)) { if (Validator.validateLength(userName, 8, 20)) { // userName is valid, continue further processing ... } } [4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。驗證輸入 numberOfChoices 是否在 10-20 之間的範例： // Example to validate the field range public Class Validator { ... public static boolean validateRange(int value, int min, int max) { return (value &gt;= min &amp;&amp; value &lt;= max); } ... } ... String fieldValue = request.getParameter(\"numberOfChoices\"); if (Validator.validateRequired(fieldValue)) { if (Validator.validateInt(fieldValue)) { int numberOfChoices = Integer.parseInt(fieldValue); if (Validator.validateRange(numberOfChoices, 10, 20)) { // numberOfChoices is valid, continue processing request ... } } } [5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。請一律對照函數需求所定義容許的選項來驗證所選的使用者值。對照容許的選項清單來驗證使用者選項的範例： // Example to validate user selection against a list of options public Class Validator { ... public static boolean validateOption(Object[] options, Object value) { boolean isValidValue = false; try { List list = Arrays.asList(options); if (list != null) { isValidValue = list.contains(value); } } catch (Exception e) { } return isValidValue; } ... } ... // Allowed options String[] options = {\"option1\", \"option2\", \"option3\"); // Verify that the user selection is one of the allowed options String userSelection = request.getParameter(\"userSelection\"); if (Validator.validateOption(options, userSelection)) { // valid user selection, continue processing request ... } [6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]*$Java 1.3 或更早的版本不包括任何正規表示式套件。建議搭配 Java 1.3 來使用「Apache 正規表示式套件」（請參閱下列「資源」），以解決這項支援欠缺。執行正規表示式驗證的範例： // Example to validate that a given value matches a specified pattern // using the Apache regular expression package import org.apache.regexp.RE; import org.apache.regexp.RESyntaxException; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { RE r = new RE(expression); match = r.match(value); } return match; } ... } ... // Verify that the userName request parameter is alpha-numeric String userName = request.getParameter(\"userName\"); if (Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { // userName is valid, continue processing request ... } Java 1.4 引進了新的正規表示式套件 (java.util.regex)。以下是 Validator.matchPattern 的修正版，使用新的 Java 1.4 正規表示式套件： // Example to validate that a given value matches a specified pattern // using the Java 1.4 regular expression package import java.util.regex.Pattern; import java.util.regexe.Matcher; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { match = Pattern.matches(expression, value); } return match; } ... } [7] Cookie 值請利用 javax.servlet.http.Cookie 物件來驗證 Cookie 值。依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。驗證必要 Cookie 值的範例： // Example to validate a required cookie value // First retrieve all available cookies submitted in the HTTP request Cookie[] cookies = request.getCookies(); if (cookies != null) { // find the \"user\" cookie for (int i=0; i&lt;cookies.length; ++i) { if (cookies[i].getName().equals(\"user\")) { // validate the cookie value if (Validator.validateRequired(cookies[i].getValue()) { // valid cookie value, continue processing request ... } } } } [8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，請將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +將機密字元轉換成對應的字元實體來過濾指定字串的範例： // Example to filter sensitive data to prevent cross-site scripting public Class Validator { ... public static String filter(String value) { if (value == null) { return null; } StringBuffer result = new StringBuffer(value.length()); for (int i=0; i&lt;value.length(); ++i) { switch (value.charAt(i)) { case '&lt;': result.append(\"&lt;\"); break; case '&gt;': result.append(\"&gt;\"); break; case '\"': result.append(\"\"\"); break; case '\\'': result.append(\"'\"); break; case '%': result.append(\"%\"); break; case ';': result.append(\";\"); break; case '(': result.append(\"(\"); break; case ')': result.append(\")\"); break; case '&amp;': result.append(\"&amp;\"); break; case '+': result.append(\"+\"); break; default: result.append(value.charAt(i)); break; } return result; } ... } ... // Filter the HTTP response using Validator.filter PrintWriter out = response.getWriter(); // set output response out.write(Validator.filter(response)); out.close(); Java Servlet API 2.3 引進了「過濾器」，它支援截取及轉換 HTTP 要求或回應。利用「Servlet 過濾器」，以 Validator.filter 來消毒回應的範例： // Example to filter all sensitive characters in the HTTP response using a Java Filter. // This example is for illustration purposes since it will filter all content in the response, including HTML tags! public class SensitiveCharsFilter implements Filter { ... public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { PrintWriter out = response.getWriter(); ResponseWrapper wrapper = new ResponseWrapper((HttpServletResponse)response); chain.doFilter(request, wrapper); CharArrayWriter caw = new CharArrayWriter(); caw.write(Validator.filter(wrapper.toString())); response.setContentType(\"text/html\"); response.setContentLength(caw.toString().length()); out.write(caw.toString()); out.close(); } ... public class CharResponseWrapper extends HttpServletResponseWrapper { private CharArrayWriter output; public String toString() { return output.toString(); } public CharResponseWrapper(HttpServletResponse response){ super(response); output = new CharArrayWriter(); } public PrintWriter getWriter(){ return new PrintWriter(output); } } } } [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，請務必利用 Cookie.setSecure（布林旗標），在 HTTP 回應中設定 Cookie 的安全旗標，以指示瀏覽器利用 HTTPS 或 SSL 之類的安全通訊協定來傳送 Cookie。維護 \"user\" Cookie 安全的範例： // Example to secure a cookie, i.e. instruct the browser to // send the cookie using a secure protocol Cookie cookie = new Cookie(\"user\", \"sensitive\"); cookie.setSecure(true); response.addCookie(cookie); 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」實作上述所有資料驗證需求，是一個功能強大的架構。這些規則配置在定義表單欄位輸入驗證規則的 XML 檔中。依預設，Struts 支援在利用 Struts 'bean:write' 標籤撰寫的所有資料上，過濾 [8] HTTP 回應中輸出的危險字元。設定 'filter=false' 旗標可以停用這個過濾。Struts 定義下列基本輸入驗證器，但也可以定義自訂驗證器：required：如果欄位含有空格以外的任何字元，便告成功。mask：如果值符合 mask 屬性給定的正規表示式，便告成功。range：如果值在 min 和 max 屬性給定的值範圍內（(value &gt;= min) 且 (value &lt;= max)），便告成功。maxLength：如果欄位長度小於或等於 max 屬性，便告成功。minLength：如果欄位長度大於或等於 min 屬性，便告成功。byte、short、integer、long、float、double：如果值可以轉換成對應的基本類型，便告成功。date：如果值代表有效日期，便告成功。可提供日期型樣。creditCard：如果值可能是有效的信用卡號碼，便告成功。e-mail：如果值可能是有效的電子郵件位址，便告成功。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件及輸入驗證的 Java API (JSR 127)。JavaServer Faces API 實作下列基本驗證器，但可以定義自訂驗證器：validate_doublerange：登錄元件的 DoubleRangeValidatorvalidate_length：登錄元件的 LengthValidatorvalidate_longrange：登錄元件的 LongRangeValidatorvalidate_required：登錄元件的 RequiredValidatorvalidate_stringrange：登錄元件的 StringRangeValidatorvalidator：登錄元件的自訂 ValidatorJavaServer Faces API 定義下列 UIInput 和 UIOutput 展現器（標籤）：input_date：接受以 java.text.Date 實例格式化的 java.util.Dateoutput_date：顯示以 java.text.Date 實例格式化的 java.util.Dateinput_datetime：接受以 java.text.Time 實例格式化的 java.util.Dateoutput_datetime：顯示以 java.text.Time 實例格式化的 java.util.Dateinput_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）output_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）input_text：接受單行字串。output_text：顯示單行字串。input_time：接受以 java.text.DateFormat 時間實例格式化的 java.util.Dateoutput_time：顯示以 java.text.DateFormat 時間實例格式化的 java.util.Dateinput_hidden：可讓頁面作者將隱藏變數併入頁面input_secret：接受不含空格的單行文字，輸入之時，將它顯示成一組星號input_textarea：接受多行文字output_errors：顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息output_label：將巢狀元件顯示為指定輸入欄位的標籤output_message：顯示本地化訊息利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 錯誤處理：許多 J2EE Web 應用程式架構都遵循「模型視圖控制器 (MVC)」型樣。在這個型樣中，Servlet 扮演控制器的角色。Servlet 將應用程式處理程序委派給 JavaBean，例如，EJB Session Bean（模型）。之後，Servlet 再將要求轉遞給 JSP（視圖）來呈現處理結果。Servlet 應該檢查所有輸入、輸出、回覆碼、錯誤碼及已知的異常狀況，以確保會實際進行預期的處理程序。資料驗證可以保護應用程式免於遭受惡意的資料竄改，有效的錯誤處理策略則是防止應用程式意外揭露內部錯誤訊息（例如：異常狀況堆疊追蹤）所不可或缺。好的錯誤處理策略會處理下列項目：[1] 定義錯誤[2] 報告錯誤[3] 呈現錯誤[4] 錯誤對映[1] 定義錯誤應該避免將錯誤訊息寫在應用程式層（例如：Servlet）。相反地，應用程式應該使用對映至已知之應用程式失敗的錯誤索引鍵。在實務中，好的做法是定義錯誤索引鍵來對映至 HTML 表單欄位或其他 Bean 內容的驗證規則。比方說，如果需要 \"user_name\" 欄位，它必須是英數字元，且在資料庫中必須是唯一，便應該定義下列錯誤索引鍵：(a) ERROR_USERNAME_REQUIRED：這個錯誤索引鍵用來顯示一則訊息，通知使用者需要 \"user_name\" 欄位；(b) ERROR_USERNAME_ALPHANUMERIC：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 欄位應該是英數字元；(c) ERROR_USERNAME_DUPLICATE：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 值在資料庫中重複；(d) ERROR_USERNAME_INVALID：這個錯誤索引鍵用來顯示一則一般訊息，通知使用者 \"user_name\" 值無效；在實務中，好的做法是定義下列架構 Java 類別來儲存及報告應用程式錯誤：- ErrorKeys：定義所有錯誤索引鍵 // Example: ErrorKeys defining the following error keys: // - ERROR_USERNAME_REQUIRED // - ERROR_USERNAME_ALPHANUMERIC // - ERROR_USERNAME_DUPLICATE // - ERROR_USERNAME_INVALID // ... public Class ErrorKeys { public static final String ERROR_USERNAME_REQUIRED = \"error.username.required\"; public static final String ERROR_USERNAME_ALPHANUMERIC = \"error.username.alphanumeric\"; public static final String ERROR_USERNAME_DUPLICATE = \"error.username.duplicate\"; public static final String ERROR_USERNAME_INVALID = \"error.username.invalid\"; ... } - Error：封裝個別錯誤 // Example: Error encapsulates an error key. // Error is serializable to support code executing in multiple JVMs. public Class Error implements Serializable { // Constructor given a specified error key public Error(String key) { this(key, null); } // Constructor given a specified error key and array of placeholder objects public Error(String key, Object[] values) { this.key = key; this.values = values; } // Returns the error key public String getKey() { return this.key; } // Returns the placeholder values public Object[] getValues() { return this.values; } private String key = null; private Object[] values = null; } - Errors：封裝錯誤的集合 // Example: Errors encapsulates the Error objects being reported to the presentation layer. // Errors are stored in a HashMap where the key is the bean property name and value is an // ArrayList of Error objects. public Class Errors implements Serializable { // Adds an Error object to the Collection of errors for the specified bean property. public void addError(String property, Error error) { ArrayList propertyErrors = (ArrayList)errors.get(property); if (propertyErrors == null) { propertyErrors = new ArrayList(); errors.put(property, propertyErrors); } propertyErrors.put(error); } // Returns true if there are any errors public boolean hasErrors() { return (errors.size &gt; 0); } // Returns the Errors for the specified property public ArrayList getErrors(String property) { return (ArrayList)errors.get(property); } private HashMap errors = new HashMap(); } 以下是利用上述架構類別來處理 \"user_name\" 欄位驗證錯誤的範例： // Example to process validation errors of the \"user_name\" field. Errors errors = new Errors(); String userName = request.getParameter(\"user_name\"); // (a) Required validation rule if (!Validator.validateRequired(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_REQUIRED)); } // (b) Alpha-numeric validation rule else if (!Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_ALPHANUMERIC)); } else { // (c) Duplicate check validation rule // We assume that there is an existing UserValidationEJB session bean that implements // a checkIfDuplicate() method to verify if the user already exists in the database. try { ... if (UserValidationEJB.checkIfDuplicate(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE)); } } catch (RemoteException e) { // log the error logger.error(\"Could not validate user for specified userName: \" + userName); errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE); } } // set the errors object in a request attribute called \"errors\" request.setAttribute(\"errors\", errors); ... [2] 報告錯誤報告 Web 層應用程式錯誤的方式有兩種：(a) Servlet 錯誤機制(b) JSP 錯誤機制[2-a] Servlet 錯誤機制Servlet 報告錯誤的可能方式如下：- 轉遞至輸入 JSP（已將錯誤儲存在要求屬性中），或- 利用 HTTP 錯誤碼引數來呼叫 response.sendError，或- 擲出異常狀況在實務中，好的做法是處理所有已知的應用程式錯誤（依照 [1] 區段所說明），將它們儲存在要求屬性中，再轉遞給輸入 JSP。輸入 JSP 應該顯示錯誤訊息，並提示使用者重新輸入資料。下列範例說明如何轉遞到輸入 JSP (userInput.jsp)： // Example to forward to the userInput.jsp following user validation errors RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd != null) { rd.forward(request, response); } 如果 Servlet 無法轉遞到已知的 JSP 頁面，第二個選項是利用 response.sendError 方法，設定 HttpServletResponse.SC_INTERNAL_SERVER_ERROR 引數（狀態碼 500）來報告錯誤。請參閱 javax.servlet.http.HttpServletResponse javadoc，以取得各種 HTTP 狀態碼的詳細資訊。傳回 HTTP 錯誤的範例： // Example to return a HTTP error code RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd == null) { // messages is a resource bundle with all message keys and values response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, messages.getMessage(ErrorKeys.ERROR_USERNAME_INVALID)); } 作為最後的手段，Servlet 可以擲出異常狀況，它必須是下列類別之一的子類別：- RuntimeException- ServletException- IOException[2-b] JSP 錯誤機制 JSP 頁面依照下列範例所示來定義 errorPage 指引，從而提供了執行時期異常狀況的處理機制： &lt;%@ page errorPage=\"/errors/userValidation.jsp\" %&gt; 未捕捉的 JSP 異常狀況是轉遞到指定的 errorPage，而原始異常狀況則設在稱為 javax.servlet.jsp.jspException 的要求參數中。錯誤頁面必須包含 isErrorPage 指引，如下所示： &lt;%@ page isErrorPage=\"true\" %&gt; isErrorPage 指引會使 \"exception\" 變數起始設定為所擲出的異常狀況物件。[3] 呈現錯誤J2SE Internationalization API 提供用來提出應用程式資源以及將訊息格式化的公用程式類別，其中包括：(a) 資源組(b) 訊息格式化[3-a] 資源組資源組會將本地化的資料與使用它的原始碼分開，從而支援國際化。每個資源組都會儲存特定語言環境之鍵值配對的對映。通常是利用或延伸 java.util.PropertyResourceBundle，它會將內容儲存在外部內容檔中，如下列範例所示： ################################################ # ErrorMessages.properties ################################################ # required user name error message error.username.required=User name field is required # invalid user name format error.username.alphanumeric=User name must be alphanumeric # duplicate user name error message error.username.duplicate=User name {0} already exists, please choose another one ... 定義多重資源可以支援不同的語言環境（因此稱為資源組）。例如，定義 ErrorMessages_fr.properties 可以支援資源組系列的法國成員。如果要求之語言環境的資源成員不存在，便會使用預設成員。在上述範例中，預設資源是 ErrorMessages.properties。依使用者的語言環境而定，應用程式（JSP 或 Servlet）會從適當的資源擷取內容。[3-b] 訊息格式化J2SE 標準類別 java.util.MessageFormat 提供以取代位置保留元來建立訊息的一般方式。MessageFormat 物件包含內嵌了格式指定元的型樣字串，如下所示： // Example to show how to format a message using placeholder parameters String pattern = \"User name {0} already exists, please choose another one\"; String userName = request.getParameter(\"user_name\"); Object[] args = new Object[1]; args[0] = userName; String message = MessageFormat.format(pattern, args); 以下是利用 ResourceBundle 和 MessageFormat 來呈現錯誤訊息的更綜合性的範例： // Example to render an error message from a localized ErrorMessages resource (properties file) // Utility class to retrieve locale-specific error messages public Class ErrorMessageResource { // Returns the error message for the specified error key in the environment locale public String getErrorMessage(String errorKey) { return getErrorMessage(errorKey, defaultLocale); } // Returns the error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Locale locale) { return getErrorMessage(errorKey, null, locale); } // Returns a formatted error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Object[] args, Locale locale) { // Get localized ErrorMessageResource ResourceBundle errorMessageResource = ResourceBundle.getBundle(\"ErrorMessages\", locale); // Get localized error message String errorMessage = errorMessageResource.getString(errorKey); if (args != null) { // Format the message using the specified placeholders args return MessageFormat.format(errorMessage, args); } else { return errorMessage; } } // default environment locale private Locale defaultLocale = Locale.getDefaultLocale(); } ... // Get the user's locale Locale userLocale = request.getLocale(); // Check if there were any validation errors Errors errors = (Errors)request.getAttribute(\"errors\"); if (errors != null &amp;&amp; errors.hasErrors()) { // iterate through errors and output error messages corresponding to the \"user_name\" property ArrayList userNameErrors = errors.getErrors(\"user_name\"); ListIterator iterator = userNameErrors.iterator(); while (iterator.hasNext()) { // Get the next error object Error error = (Error)iterator.next(); String errorMessage = ErrorMessageResource.getErrorMessage(error.getKey(), userLocale); output.write(errorMessage + \"\\r\\n\"); } } 建議您定義自訂 JSP 標籤（如 displayErrors）來疊代處理及呈現錯誤訊息，如上述範例所示。[4] 錯誤對映一般而言，「Servlet 儲存器」會傳回對應於回應狀態碼或異常狀況的預設錯誤頁面。您可以利用自訂錯誤頁面來指定狀態碼或異常狀況與 Web 資源之間的對映。在實務中，好的做法是開發不揭露內部錯誤狀態的靜態錯誤頁面（依預設，大部分 Servlet 儲存器都會報告內部錯誤訊息）。這項對映是依照下列範例所指定，配置在「Web 部署描述子 (web.xml)」中： &lt;!-- Mapping of HTTP error codes and application exceptions to error pages --&gt; &lt;error-page&gt; &lt;exception-type&gt;UserValidationException&lt;/exception-type&gt; &lt;location&gt;/errors/validationError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/exception-type&gt; &lt;location&gt;/errors/internalError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; ... &lt;/error-page&gt; ... 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」是依照上述說明來定義錯誤處理機制的 Java 架構。驗證規則配置在 XML 檔中，檔案定義了表單欄位的輸入驗證規則以及對應的驗證錯誤索引鍵。Struts 提供國際化支援，供您利用資源組和訊息格式化來建置本地化應用程式。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; Struts JSP 標籤庫定義了有條件地顯示一組累計錯誤訊息的 \"errors\" 標籤，如下列範例所示： &lt;%@ page language=\"java\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-html.tld\" prefix=\"html\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-bean.tld\" prefix=\"bean\" %&gt; &lt;html:html&gt; &lt;head&gt; &lt;body&gt; &lt;html:form action=\"/logon.do\"&gt; &lt;table border=\"0\" width=\"100%\"&gt; &lt;tr&gt; &lt;th align=\"right\"&gt; &lt;html:errors property=\"username\"/&gt; &lt;bean:message key=\"prompt.username\"/&gt; &lt;/th&gt; &lt;td align=\"left\"&gt; &lt;html:text property=\"username\" size=\"16\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt; &lt;html:submit&gt;&lt;bean:message key=\"button.submit\"/&gt;&lt;/html:submit&gt; &lt;/td&gt; &lt;td align=\"right\"&gt; &lt;html:reset&gt;&lt;bean:message key=\"button.reset\"/&gt;&lt;/html:reset&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/html:form&gt; &lt;/body&gt; &lt;/html:html&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件、驗證輸入，以及支援國際化的 Java API (JSR 127)。JavaServer Faces API 定義了 \"output_errors\" UIOutput 展現器，以顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息。利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 過濾使用者輸入將任何資料傳給 SQL 查詢之前，一律應該先利用白名單技術來適當過濾。這無論如何強調都不為過。過濾使用者輸入可讓許多注入缺失，在抵達資料庫之前便得到更正。** 引用使用者輸入不論任何資料類型，只要資料庫允許，便用單引號括住所有使用者資料，始終是好的觀念。MySQL 接受這個格式化技術。** 跳出資料值如果您使用 MySQL 4.3.0 或更新的版本，您應該用 mysql_real_escape_string() 來跳出所有字串。如果使用舊版的 MySQL，便應該使用 mysql_escape_string() 函數。如果未使用 MySQL，您可以選擇使用特定資料庫的特定跳出函數。如果不知道跳出函數，您可以選擇使用較一般的跳出函數，例如，addslashes()。如果使用 PEAR DB 資料庫抽象層，您可以使用 DB::quote() 方法或使用 ? 之類的查詢位置保留元，它會自動跳出取代位置保留元的值。參照http://ca3.php.net/mysql_real_escape_stringhttp://ca.php.net/mysql_escape_stringhttp://ca.php.net/addslasheshttp://pear.php.net/package-info.php?package=DB** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但一律必須在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是實作一或多個驗證各個應用程式參數的函數。下列各節說明一些檢查範例。[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // PHP example to validate required fields function validateRequired($input) { ... $pass = false; if (strlen(trim($input))&gt;0){ $pass = true; } return $pass; ... } ... if (validateRequired($fieldName)) { // fieldName is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。[4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。[5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。請一律對照函數需求所定義容許的選項來驗證所選的使用者值。[6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]+$[7] Cookie 值依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。[8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，開發人員應該將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +PHP 包括一些 htmlentities() 之類的自動化消毒公用程式函數： $input = htmlentities($input, ENT_QUOTES, 'UTF-8'); 此外，為了避免「跨網站指令碼」的 UTF-7 變式，您應該明確定義回應的 Content-Type 標頭，例如： &lt;?php header('Content-Type: text/html; charset=UTF-8'); ?&gt; [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，且透過 SSL 來傳輸它時，請務必先在 HTTP 回應中設定 Cookie 的安全旗標。這會指示瀏覽器只透過 SSL 連線來使用這個 Cookie。您可以利用下列程式碼範例來維護 Cookie 安全： &lt;$php $value = \"some_value\"; $time = time()+3600; $path = \"/application/\"; $domain = \".example.com\"; $secure = 1; setcookie(\"CookieName\", $value, $time, $path, $domain, $secure, TRUE); ?&gt; 此外，我們建議您使用 HttpOnly 旗標。當 HttpOnly 旗標設為 TRUE 時，只能透過 HTTP 通訊協定來存取 Cookie。這表示無法用 JavaScript 之類的 Scripting 語言存取 Cookie。這個設定有助於實際減少透過 XSS 攻擊來盜用身分的情況（不過，並非所有瀏覽器都支援）。PHP 5.2.0 新增 HttpOnly 旗標。參照[1] 利用「HTTP 專用 Cookie」緩和「跨網站指令碼」： http://msdn2.microsoft.com/en-us/library/ms533046.aspx[2] PHP 安全聯盟： http://phpsec.org/[3] PHP &amp; Web 應用程式安全部落格 (Chris Shiflett)： http://shiflett.org/<w:br w:type=\"page\"/>"
        },
        {
            "name": "反映型跨網站指令碼",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "高",
            "cvss": "7.1",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/Search.asp",
            "entity": "tfSearch (Parameter)",
            "risk": "有可能竊取或操作客戶階段作業和 Cookie，並可能用來假冒合法的使用者，讓駭客可以檢視或變更使用者記錄，以及用該使用者的身分來執行交易\n",
            "cause": "未正確地消毒使用者所輸入的危險字元",
            "solution": "檢查危險字元注入可能的解決方案",
            "mark": "tfSearch=\"/><script>alert(83)</script>",
            "solution_description": "XSS 攻擊可以公開使用者的階段作業 Cookie，容許攻擊者強制存取使用者的階段作業以及存取使用者的帳戶，進而導致模擬使用者。攻擊者可以修改和檢視使用者記錄，以及以這些使用者的身分執行交易。攻擊者可能可以代表使用者來執行特許作業，或存取任何屬於使用者的機密資料。如果使用者具有管理員許可權，則此情況特別危險。攻擊者甚至可以在受害者的瀏覽器上執行惡意 Script，而此 Script 會將使用者重新導向至其他頁面或網站、修改內容呈現，或是甚至可能執行惡意軟體或加密採礦程式。",
            "solution_suggest": "完整編碼來自插入至網頁之不受信任來源的所有動態資料，以確保將其視為純文字，而非可執行的 Script 或可呈現的標記。請考慮要在其中使用資料的環境定義，並且盡可能依環境定義將資料編碼為接近實際輸出：例如適用於 HTML 內容的 HTML 編碼；適用於屬性值之資料輸出的 HTML 屬性編碼；適用於動態產生之 JavaScript 的 JavaScript 編碼。例如，HTML 將非英數字元編碼為 HTML 實體時，`&lt;` 和 `&gt;` 將會變成 `&amp;lt;` 和 `&amp;gt;`。額外的防範措施是不論來源為何，都會驗證伺服器上的所有外部輸入。請依據定義資料類型、大小、範圍、格式和可接受值的嚴密正面規格（容許清單），仔細檢查每個輸入參數。在部分情況下，正規表示式或架構控制項可能十分有用，但這不是輸出編碼的取代項目。無論來源為何，都必須完成所有不受信任資料的輸出編碼和資料驗證：例如表單欄位、URL 參數、Web 服務引數、Cookie、任何來自網路的資料、環境變數、反向 DNS 查閱、查詢結果、要求標頭、URL 元件、電子郵件、檔案和檔名、資料庫，以及所有向應用程式提供資料的外部系統。請記住，可以透過 API 呼叫間接取得這類輸入。針對伺服器所傳回的每個網頁，明確地設定 `Content-Type` HTTP 回應標頭。此標頭值應該定義特定字元編碼（字集）。例如 `ISO-8859-1` 或 `UTF-8`。未指定編碼時，Web 瀏覽器可能會猜測網頁實際使用的編碼以選擇不同的編碼，但這樣容許潛在的攻擊者略過 XSS 保護。此外，請在階段作業 Cookie 上設定 `httpOnly` 旗標，防止任何 XSS 惡意探索竊取使用者的 Cookie。偏好使用可根據環境定義自動編碼所有動態輸出以防止此弱點的架構或標準程式庫，或至少提供的建構可更輕鬆地避免弱點。針對伺服器所傳回的每個網頁，明確地設定 `Content-Security-Policy` HTTP 回應標頭，讓攻擊者更難實際惡意探索 XSS 攻擊。<w:br w:type=\"page\"/>"
        },
        {
            "name": "擷取毒害空值位元組 Windows 檔案",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "高",
            "cvss": "7.5",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/Templatize.asp",
            "entity": "item (Parameter)",
            "risk": "有可能檢視 Web 伺服器上任何檔案（例如：資料庫、使用者資訊或配置檔）的內容，但受 Web 伺服器使用者的許可權限制\n",
            "cause": "未正確地消毒使用者所輸入的危險字元未檢查使用者輸入是否有 '..' （雙點）字串",
            "solution": "確定所存取的檔案位於虛擬路徑中，且具有特定副檔名；從使用者輸入移除特殊字元",
            "mark": "item=/../../../../../../../../../../../../windows/win.ini%00.html",
            "solution_description": "攻擊者可能會修改、刪除或讀取 Web 伺服器上應用程式可存取之任何檔案（例如，資料庫、使用者資訊或配置檔）的內容。攻擊者可能嘗試毀損或移除應用程式或作業系統所使用的重要檔案進而導致 DoS 攻擊，甚至將資料新增至檔案。攻擊也可以用來刪除日誌檔案，內含可用來追蹤攻擊者的資訊。",
            "solution_suggest": "若要防止此類型的攻擊，您應該先消毒由使用者提供且將用來建置路徑的所有資料 。此作業的最佳方式是使用容許清單。容許清單是應用程式將接受的已接受值清單。例如，由使用者提供且要插入至路徑字串之資料的容許清單將會只有可能容許底線 (_) 和橫線 (-) 字元的英數字元。除了使用容許清單技術之外，伺服器應禁止存取檔案系統的所有區域，但特別用於 Web 應用程式的區域除外。這將防止使用者嘗試中斷 Web 應用程式目錄以及存取檔案系統之其他區域中的檔案。強制只能開啟特定副檔名移除使用者輸入中的特殊字元（中繼字元），例如垂直線 (|) 字元先標準化路徑名稱，再對其進行驗證<w:br w:type=\"page\"/>"
        },
        {
            "name": "整數溢位",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "高",
            "cvss": "8.6",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:L/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/showthread.asp",
            "entity": "id (Parameter)",
            "risk": "有可能收集機密性除錯資訊\n",
            "cause": "未對送入的參數值執行適當的範圍檢查未執行驗證，以確定使用者輸入符合預期的資料類型",
            "solution": "請驗證參數值是在預期的範圍內且為預期的類型。請勿輸出除錯錯誤訊息和異常狀況",
            "mark": "id=99999999999999999999",
            "solution_description": "發生整數溢位時，解譯的值似乎已回歸超過最大值，並重設回最小值。值可以非預期地變為零或負值。如果使用該值來控制迴圈、管理資源（例如記憶體配置）或進行商業邏輯決策，則這可能會有安全隱患。例如，交易完成時，除了客戶所購買的東西之外，整數溢位可能還會把錢給客戶。特別是，如果數學運算導致可能大於整數類型最大值的數字，則值會回歸，而且變數會設定為零或負值。i=UINT_MAX+1; // 不帶正負號整數類型之變數的最大值 - 4294967295 (0xffffffff)。結果是：i=0",
            "solution_suggest": "先驗證所有輸入都在預期範圍內以及正負號，再依賴其值或將它們用於算數計算。請務必檢查上下限，包括帶正負號之整數的負下限（整數溢位也可能具有極大的負數）。可能的話，請使用不帶正負號的整數。請考慮使用安全整數處理程式庫（例如 C/C++ SafeInt 或 IntegerLib）。請考慮啟用可防止部分緩衝區溢位類別的編譯器延伸。<w:br w:type=\"page\"/>"
        },
        {
            "name": "預存的跨網站指令碼",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "高",
            "cvss": "7.1",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/showthread.asp",
            "entity": "showthread.asp (Global)",
            "risk": "有可能竊取或操作客戶階段作業和 Cookie，並可能用來假冒合法的使用者，讓駭客可以檢視或變更使用者記錄，以及用該使用者的身分來執行交易\n",
            "cause": "未正確地消毒使用者所輸入的危險字元",
            "solution": "檢查危險字元注入可能的解決方案",
            "mark": "X-Forwarded-For: '",
            "solution_description": "XSS 攻擊可以公開使用者的階段作業 Cookie，容許攻擊者強制存取使用者的階段作業以及存取使用者的帳戶，進而導致模擬使用者。攻擊者可以修改和檢視使用者記錄，以及以這些使用者的身分執行交易。攻擊者可能可以代表使用者來執行特許作業，或存取任何屬於使用者的機密資料。如果使用者具有管理員許可權，則此情況特別危險。攻擊者甚至可以在受害者的瀏覽器上執行惡意 Script，而此 Script 會將使用者重新導向至其他頁面或網站、修改內容呈現，或是甚至可能執行惡意軟體或加密採礦程式。",
            "solution_suggest": "完整編碼來自插入至網頁之不受信任來源的所有動態資料，以確保將其視為純文字，而非可執行的 Script 或可呈現的標記。請考慮要在其中使用資料的環境定義，並且盡可能依環境定義將資料編碼為接近實際輸出：例如適用於 HTML 內容的 HTML 編碼；適用於屬性值之資料輸出的 HTML 屬性編碼；適用於動態產生之 JavaScript 的 JavaScript 編碼。例如，HTML 將非英數字元編碼為 HTML 實體時，`&lt;` 和 `&gt;` 將會變成 `&amp;lt;` 和 `&amp;gt;`。額外的防範措施是不論來源為何，都會驗證伺服器上的所有外部輸入。請依據定義資料類型、大小、範圍、格式和可接受值的嚴密正面規格（容許清單），仔細檢查每個輸入參數。在部分情況下，正規表示式或架構控制項可能十分有用，但這不是輸出編碼的取代項目。無論來源為何，都必須完成所有不受信任資料的輸出編碼和資料驗證：例如表單欄位、URL 參數、Web 服務引數、Cookie、任何來自網路的資料、環境變數、反向 DNS 查閱、查詢結果、要求標頭、URL 元件、電子郵件、檔案和檔名、資料庫，以及所有向應用程式提供資料的外部系統。請記住，可以透過 API 呼叫間接取得這類輸入。針對伺服器所傳回的每個網頁，明確地設定 `Content-Type` HTTP 回應標頭。此標頭值應該定義特定字元編碼（字集）。例如 `ISO-8859-1` 或 `UTF-8`。未指定編碼時，Web 瀏覽器可能會猜測網頁實際使用的編碼以選擇不同的編碼，但這樣容許潛在的攻擊者略過 XSS 保護。此外，請在階段作業 Cookie 上設定 `httpOnly` 旗標，防止任何 XSS 惡意探索竊取使用者的 Cookie。偏好使用可根據環境定義自動編碼所有動態輸出以防止此弱點的架構或標準程式庫，或至少提供的建構可更輕鬆地避免弱點。針對伺服器所傳回的每個網頁，明確地設定 `Content-Security-Policy` HTTP 回應標頭，讓攻擊者更難實際惡意探索 XSS 攻擊。<w:br w:type=\"page\"/>"
        },
        {
            "name": "預存的跨網站指令碼",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "高",
            "cvss": "7.1",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/showthread.asp",
            "entity": "id (Global)",
            "risk": "有可能竊取或操作客戶階段作業和 Cookie，並可能用來假冒合法的使用者，讓駭客可以檢視或變更使用者記錄，以及用該使用者的身分來執行交易\n",
            "cause": "未正確地消毒使用者所輸入的危險字元",
            "solution": "檢查危險字元注入可能的解決方案",
            "mark": "o not follow links that are post",
            "solution_description": "XSS 攻擊可以公開使用者的階段作業 Cookie，容許攻擊者強制存取使用者的階段作業以及存取使用者的帳戶，進而導致模擬使用者。攻擊者可以修改和檢視使用者記錄，以及以這些使用者的身分執行交易。攻擊者可能可以代表使用者來執行特許作業，或存取任何屬於使用者的機密資料。如果使用者具有管理員許可權，則此情況特別危險。攻擊者甚至可以在受害者的瀏覽器上執行惡意 Script，而此 Script 會將使用者重新導向至其他頁面或網站、修改內容呈現，或是甚至可能執行惡意軟體或加密採礦程式。",
            "solution_suggest": "完整編碼來自插入至網頁之不受信任來源的所有動態資料，以確保將其視為純文字，而非可執行的 Script 或可呈現的標記。請考慮要在其中使用資料的環境定義，並且盡可能依環境定義將資料編碼為接近實際輸出：例如適用於 HTML 內容的 HTML 編碼；適用於屬性值之資料輸出的 HTML 屬性編碼；適用於動態產生之 JavaScript 的 JavaScript 編碼。例如，HTML 將非英數字元編碼為 HTML 實體時，`&lt;` 和 `&gt;` 將會變成 `&amp;lt;` 和 `&amp;gt;`。額外的防範措施是不論來源為何，都會驗證伺服器上的所有外部輸入。請依據定義資料類型、大小、範圍、格式和可接受值的嚴密正面規格（容許清單），仔細檢查每個輸入參數。在部分情況下，正規表示式或架構控制項可能十分有用，但這不是輸出編碼的取代項目。無論來源為何，都必須完成所有不受信任資料的輸出編碼和資料驗證：例如表單欄位、URL 參數、Web 服務引數、Cookie、任何來自網路的資料、環境變數、反向 DNS 查閱、查詢結果、要求標頭、URL 元件、電子郵件、檔案和檔名、資料庫，以及所有向應用程式提供資料的外部系統。請記住，可以透過 API 呼叫間接取得這類輸入。針對伺服器所傳回的每個網頁，明確地設定 `Content-Type` HTTP 回應標頭。此標頭值應該定義特定字元編碼（字集）。例如 `ISO-8859-1` 或 `UTF-8`。未指定編碼時，Web 瀏覽器可能會猜測網頁實際使用的編碼以選擇不同的編碼，但這樣容許潛在的攻擊者略過 XSS 保護。此外，請在階段作業 Cookie 上設定 `httpOnly` 旗標，防止任何 XSS 惡意探索竊取使用者的 Cookie。偏好使用可根據環境定義自動編碼所有動態輸出以防止此弱點的架構或標準程式庫，或至少提供的建構可更輕鬆地避免弱點。針對伺服器所傳回的每個網頁，明確地設定 `Content-Security-Policy` HTTP 回應標頭，讓攻擊者更難實際惡意探索 XSS 攻擊。<w:br w:type=\"page\"/>"
        },
        {
            "name": "Microsoft FrontPage 目錄清單",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "中",
            "cvss": "6.5",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "_vti_cnf/ (Page)",
            "risk": "有可能檢視及下載某些 Web 應用程式虛擬目錄的內容，其可能包含受限的檔案\n",
            "cause": "已使用不適當的安全設定來安裝 FrontPage Server Extensions",
            "solution": "修改伺服器配置來拒絕存取含有機密性資訊的目錄",
            "mark": "/_vti_cnf/",
            "solution_description": "有可能檢視及下載某些 Web 應用程式虛擬目錄的內容，其可能包含受限的檔案Web 伺服器通常配置成不允許目錄清單含有 Script 或文字內容。部分第三方產品會建立含有正式作業檔案之副本的輔助目錄。如果存取這些目錄並不受限，攻擊者便可以下載這些目錄中的檔案。Microsoft 的 FrontPage 便是會建立這類輔助目錄的產品。",
            "solution_suggest": "請確定 Web 伺服器用戶端無法直接存取這類產品所建立的目錄（如 CVS、RCS 或 FrontPage 目錄）。請將 Web 伺服器配置成這些目錄都不可存取（所有一般 Web 伺服器都有拒絕存取特定目錄的選項）。<w:br w:type=\"page\"/>"
        },
        {
            "name": "SameSite 屬性不安全、不適當或遺漏的 Cookie",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "中",
            "cvss": "4.7",
            "cvss_vector": "AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N/E:U/RL:O/RC:C/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "ASPSESSIONIDSQRQRDTS (Cookie)",
            "risk": "將 Cookie 限制為第一方或相同網站環境定義以預防 Cookie 資訊洩漏。如果沒有設置額外的保護措施（如反 CSRF 記號），攻擊者可以延伸為偽造跨網站要求 (CSRF) 攻擊。\n",
            "cause": "SameSite 屬性不適當、不安全或遺漏的機密 Cookie",
            "solution": "檢閱將 SameSite Cookie 屬性配置為建議值的可能解決方案",
            "mark": "",
            "solution_description": "將 Cookie 限制為第一方或相同網站環境定義，藉此預防 Cookie 資訊洩漏。如果沒有設置額外的保護措施（如反 CSRF 記號），攻擊者可以延伸為偽造跨網站要求 (CSRF) 攻擊。SameSite 屬性控制跨網域要求的 Cookie 傳送方式。屬性的值有三個：「Lax」、「Strict」或「None」。如果您使用「None」，網站可以建立與其他網站之間的跨網域 POST HTTP 要求，而瀏覽器會自動將 Cookie 新增到該要求中。如果沒有設置額外的保護措施（如反 CSRF 記號），可能會引發偽造跨網站要求 (CSRF) 攻擊。模式與其用法：「Lax」模式：Cookie 只會連同最上層 GET 要求一同傳送。「Strict」模式：即使使用者遵循其他網站的鏈結，Cookie 也不會連同任何跨網站用法一同傳送。「None」模式：Cookie 將連同跨網站要求一同傳送。擁有「Lax」或「None」的屬性必須設定「Secure」旗標，而且必須透過 https 傳輸。範例 - Set-Cookie: key=value; SameSite=Lax;Secure建議選項是將屬性設定為「Strict」。範例 - Set-Cookie: key=value; SameSite=Strict",
            "solution_suggest": "[1] 檢閱將 SameSite Cookie 屬性配置為建議值的可能解決方案。[2] 將 Cookie 限制為第一方或相同網站環境定義。[3] 將 Cookie 的 SameSite 屬性設定為 Strict 並加以驗證，確保 Cookie 只能在第一方環境定義中傳送。[4] 或者，如果您想要放鬆第一方環境定義的限制，請將 Cookie 的 SameSite 屬性設定為 Lax 並啟用 Secure 旗標，再透過 HTTPS 傳輸，同時加以驗證。<w:br w:type=\"page\"/>"
        },
        {
            "name": "SameSite 屬性不安全、不適當或遺漏的 Cookie",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "中",
            "cvss": "4.7",
            "cvss_vector": "AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N/E:U/RL:O/RC:C/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "ASPSESSIONIDQQQQQDST (Cookie)",
            "risk": "將 Cookie 限制為第一方或相同網站環境定義以預防 Cookie 資訊洩漏。如果沒有設置額外的保護措施（如反 CSRF 記號），攻擊者可以延伸為偽造跨網站要求 (CSRF) 攻擊。\n",
            "cause": "SameSite 屬性不適當、不安全或遺漏的機密 Cookie",
            "solution": "檢閱將 SameSite Cookie 屬性配置為建議值的可能解決方案",
            "mark": "",
            "solution_description": "將 Cookie 限制為第一方或相同網站環境定義，藉此預防 Cookie 資訊洩漏。如果沒有設置額外的保護措施（如反 CSRF 記號），攻擊者可以延伸為偽造跨網站要求 (CSRF) 攻擊。SameSite 屬性控制跨網域要求的 Cookie 傳送方式。屬性的值有三個：「Lax」、「Strict」或「None」。如果您使用「None」，網站可以建立與其他網站之間的跨網域 POST HTTP 要求，而瀏覽器會自動將 Cookie 新增到該要求中。如果沒有設置額外的保護措施（如反 CSRF 記號），可能會引發偽造跨網站要求 (CSRF) 攻擊。模式與其用法：「Lax」模式：Cookie 只會連同最上層 GET 要求一同傳送。「Strict」模式：即使使用者遵循其他網站的鏈結，Cookie 也不會連同任何跨網站用法一同傳送。「None」模式：Cookie 將連同跨網站要求一同傳送。擁有「Lax」或「None」的屬性必須設定「Secure」旗標，而且必須透過 https 傳輸。範例 - Set-Cookie: key=value; SameSite=Lax;Secure建議選項是將屬性設定為「Strict」。範例 - Set-Cookie: key=value; SameSite=Strict",
            "solution_suggest": "[1] 檢閱將 SameSite Cookie 屬性配置為建議值的可能解決方案。[2] 將 Cookie 限制為第一方或相同網站環境定義。[3] 將 Cookie 的 SameSite 屬性設定為 Strict 並加以驗證，確保 Cookie 只能在第一方環境定義中傳送。[4] 或者，如果您想要放鬆第一方環境定義的限制，請將 Cookie 的 SameSite 屬性設定為 Lax 並啟用 Secure 旗標，再透過 HTTPS 傳輸，同時加以驗證。<w:br w:type=\"page\"/>"
        },
        {
            "name": "Windows 檔案參數變更",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "中",
            "cvss": "6.5",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/Templatize.asp",
            "entity": "item (Parameter)",
            "risk": "有可能檢視 Web 伺服器上任何檔案（例如：資料庫、使用者資訊或配置檔）的內容，但受 Web 伺服器使用者的許可權限制\n",
            "cause": "未正確地消毒使用者所輸入的危險字元未檢查使用者輸入是否有 '..' （雙點）字串",
            "solution": "確定所存取的檔案位於虛擬路徑中，且具有特定副檔名；從使用者輸入移除特殊字元",
            "mark": "item=/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/windows/win.ini%00.html",
            "solution_description": "有可能檢視 Web 伺服器上任何檔案（例如：資料庫、使用者資訊或配置檔）的內容，但受 Web 伺服器使用者的許可權限制CGI Script 通常含有一些參數，用來指定顯示的檔案或作為範本的檔案。如果應用程式未驗證提供給 Script 的檔名，攻擊者就可以操作這個參數，然後要求在伺服器上的其他檔案。範例：[原始 HTML 表單] &lt;FORM METHOD=POST ACTION=\"/cgi-bin/vulnerable_script.cgi\"&gt; ... &lt;INPUT TYPE=HIDDEN NAME=\"template\" VALUE=\"/dir1/dir2/template.txt\"&gt; ... &lt;/FORM&gt; [操作的 HTML 表單] &lt;FORM METHOD=POST ACTION=\"http://target/cgi-bin/vulnerable_script.cgi\"&gt; ... &lt;INPUT TYPE=HIDDEN NAME=\"template\" VALUE=\"../../../../../boot.ini\"&gt; ... &lt;/FORM&gt; 如此一來，當應用程式將表單提交回伺服器時，會向攻擊者提供 boot.ini 檔。附註：這項攻擊有可能改為利用 \"\\\"，或與 \"/\" 交換，以形成變式。因此，可能使用 ../../../../../boot.ini, ..\\..\\..\\..\\..\\boot.ini 和 ..\\../../..\\../boot.ini。",
            "solution_suggest": "[1] 確定要求的檔案在 Web 伺服器的虛擬路徑中。[2] 確定只能開啟特定副檔名[3] 從使用者輸入中移除特殊字元（meta 字元），例如：垂直線 (\"|\") 字元。[4] 在 Perl CGI Script 中，檔案使用「明確開啟」模式。ASP.NET 提供了一些先驗證檔名再開啟檔案的方法。例如：[1] Server.MapPath() 方法：這個方法會接收一個路徑（字串），再將指定的相對或虛擬路徑對映到伺服器上相對應的實體目錄。附註：AspEnableParentPaths 內容（Metabase 內容）的預設值是 FALSE，以確保 Script 不會有應用程式根目錄以外的檔案存取權。將這個內容值改成 TRUE 會構成潛在的安全風險。[2] Path.GetFileName() 方法：這個方法會有效移除給定檔案路徑的最後一個元素，傳回由檔案路徑中最後一個分隔字元之前的所有字元所組成的字串（不包括最後一個分隔字元）。附註：如果這個方法的引數包括如下 'InvalidPathChars'，便會發出 'ArgumentException'：a. 引號 (\")b. 小於 (&lt;)c. 大於 (&gt;)d. 垂直線 (|)e. 倒退鍵 (\\b)f. 空值 (\\0)g. Unicode 字元 16 至 18 和 20 至 25。基於安全考量，我們建議您先使用 Server.MapPath() 方法，再執行檔名的任何輸入驗證。** 檔案路徑驗證：您可以利用多種方法從「Servlet 儲存器」存取檔案系統。不過，部分方法有危險，因為它們支援在 Web 根目錄之外存取檔案。給定虛擬路徑在伺服器的文件樹狀結構中，有兩種安全的 Servlet API 方法可用來存取 Web 資源。當給定檔名解析為在 Web 根目錄之外的值時，這些 API 會傳回空值。應該利用下列 API 來存取儲存在 Web 根目錄之下的配置檔或其他檔案：[1] ServletContext.getResource（或 ServletContext.getResourceAsStream）[2] ServletContext.getRealPath[1] ServletContext.getResource（或 ServletContext.getResourceAsStream）ServletContext.getResource 或 ServletContext.getResourceAsStream 可用來存取位於虛擬路徑（相對於伺服器的 Web 根目錄）的資源。資源可以在本端或遠端檔案系統上，在資料庫中，或在 .war 檔中。ServletContext.getResource 會傳回對映至指定路徑之資源的 URL。如果沒有資源對映至指定的路徑，它會傳回空值。如果指定路徑的形式不正確，它會擲出 MalFormedURLException。ServletContext.getResourceAsStream 會傳回對映至指定路徑之資源的 InputStream 物件。如果沒有有效資源對映至指定的路徑，它會傳回空值。下列範例說明如何載入在應用程式 WEB-INF 目錄中，名稱為 servlet.xml 的 Servlet 配置檔： // Example to load the /WEB-INF/servlet.xml configuration file URL url = getServletContext().getResource(\"/WEB-INF/servlet.xml\"); // Acquire an input stream to the config resource InputStream configInput = url.openStream(); ... 另外，您也可以依照下列範例所說明，利用 ServletContext.getResourceAsStream 方法來直接獲得配置檔的輸入串流： // Example to acquire an input stream to a resource InputStream configInput = getServletContext().getResourceAsStream(\"/WEB-INF/servlet.xml\"); ... [2] ServletContext.getRealPath給定資源的虛擬路徑（相對於伺服器的 Web 根目錄），這個方法會傳回資源的真實路徑。真實路徑以執行 Servlet 儲存器的電腦和作業系統所適用的形式傳回，其中包括適當的路徑分隔字元。這個方法的通行程度低於 ServletContext.getResource（或 ServletContext.getResourceAsStream），因為它不允許存取未儲存在本端檔案的資源。如果 Servlet 儲存器為了任何原因（例如：從 .war 保存檔啟用內容），無法將虛擬路徑轉換成真實路徑，它會傳回空值。請注意，Servlet 引擎負責實作 ServletContext.getRealPath 方法。在所有 Servlet 引擎中，這項實作有可能不一致或不正確。請一律依照下列範例所說明來驗證傳回的路徑： // Example to access a resource using ServletContext.getRealPath // Get the virtual path parameter from the http request String virtualPath = request.getParameter(\"virtual_path\"); String realPath = getServletContext().getRealPath(virtualPath); if (realPath != null) { // verify that realPath is valid File file = new File(realPath); if (!file.exists()) { // oops, invalid path ... } } 建議的 Java 工具N/A.參照https://www.programcreek.com/java-api-examples/?class=javax.servlet.ServletContext&amp;method=getResourcehttps://www.programcreek.com/java-api-examples/?class=javax.servlet.ServletContext&amp;method=getResourceAsStreamhttps://www.programcreek.com/java-api-examples/?class=javax.servlet.ServletContext&amp;method=getRealPath**驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但必須利用 Servlet，在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是在 \"Validator\" 公用程式類別中將上述常式當作靜態方法來實作。下列各節說明範例驗證器類別[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // Java example to validate required fields public Class Validator { ... public static boolean validateRequired(String value) { boolean isFieldValid = false; if (value != null &amp;&amp; value.trim().length() &gt; 0) { isFieldValid = true; } return isFieldValid; } ... } ... String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateRequired(fieldValue)) { // fieldValue is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。請利用 Java 基本封套類別來檢查欄位值是否能安全轉換成所需要的基本資料類型。如何驗證數值欄位（int 類型）的範例： // Java example to validate that a field is an int number public Class Validator { ... public static boolean validateInt(String value) { boolean isFieldValid = false; try { Integer.parseInt(value); isFieldValid = true; } catch (Exception e) { isFieldValid = false; } return isFieldValid; } ... } ... // check if the HTTP request parameter is of type int String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // fieldValue is valid, continue processing request ... } 在實務中，好的做法是將所有 HTTP 要求參數轉換成它們的相關資料類型。請將要求參數的 \"integerValue\" 儲存在要求屬性中，再依照下列範例所示來使用它： // Example to convert the HTTP request parameter to a primitive wrapper data type // and store this value in a request attribute for further processing String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // convert fieldValue to an Integer Integer integerValue = Integer.getInteger(fieldValue); // store integerValue in a request attribute request.setAttribute(\"fieldName\", integerValue); } ... // Use the request attribute for further processing Integer integerValue = (Integer)request.getAttribute(\"fieldName\"); ... 應用程式應該處理的主要 Java 資料類型：- Byte- Short- Integer- Long- Float- Double- Date[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。驗證 userName 欄位的長度是否在 8-20 個字元之間的範例： // Example to validate the field length public Class Validator { ... public static boolean validateLength(String value, int minLength, int maxLength) { String validatedValue = value; if (!validateRequired(value)) { validatedValue = \"\"; } return (validatedValue.length() &gt;= minLength &amp;&amp; validatedValue.length() &lt;= maxLength); } ... } ... String userName = request.getParameter(\"userName\"); if (Validator.validateRequired(userName)) { if (Validator.validateLength(userName, 8, 20)) { // userName is valid, continue further processing ... } } [4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。驗證輸入 numberOfChoices 是否在 10-20 之間的範例： // Example to validate the field range public Class Validator { ... public static boolean validateRange(int value, int min, int max) { return (value &gt;= min &amp;&amp; value &lt;= max); } ... } ... String fieldValue = request.getParameter(\"numberOfChoices\"); if (Validator.validateRequired(fieldValue)) { if (Validator.validateInt(fieldValue)) { int numberOfChoices = Integer.parseInt(fieldValue); if (Validator.validateRange(numberOfChoices, 10, 20)) { // numberOfChoices is valid, continue processing request ... } } } [5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。請一律對照函數需求所定義容許的選項來驗證所選的使用者值。對照容許的選項清單來驗證使用者選項的範例： // Example to validate user selection against a list of options public Class Validator { ... public static boolean validateOption(Object[] options, Object value) { boolean isValidValue = false; try { List list = Arrays.asList(options); if (list != null) { isValidValue = list.contains(value); } } catch (Exception e) { } return isValidValue; } ... } ... // Allowed options String[] options = {\"option1\", \"option2\", \"option3\"); // Verify that the user selection is one of the allowed options String userSelection = request.getParameter(\"userSelection\"); if (Validator.validateOption(options, userSelection)) { // valid user selection, continue processing request ... } [6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]*$Java 1.3 或更早的版本不包括任何正規表示式套件。建議搭配 Java 1.3 來使用「Apache 正規表示式套件」（請參閱下列「資源」），以解決這項支援欠缺。執行正規表示式驗證的範例： // Example to validate that a given value matches a specified pattern // using the Apache regular expression package import org.apache.regexp.RE; import org.apache.regexp.RESyntaxException; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { RE r = new RE(expression); match = r.match(value); } return match; } ... } ... // Verify that the userName request parameter is alpha-numeric String userName = request.getParameter(\"userName\"); if (Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { // userName is valid, continue processing request ... } Java 1.4 引進了新的正規表示式套件 (java.util.regex)。以下是 Validator.matchPattern 的修正版，使用新的 Java 1.4 正規表示式套件： // Example to validate that a given value matches a specified pattern // using the Java 1.4 regular expression package import java.util.regex.Pattern; import java.util.regexe.Matcher; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { match = Pattern.matches(expression, value); } return match; } ... } [7] Cookie 值請利用 javax.servlet.http.Cookie 物件來驗證 Cookie 值。依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。驗證必要 Cookie 值的範例： // Example to validate a required cookie value // First retrieve all available cookies submitted in the HTTP request Cookie[] cookies = request.getCookies(); if (cookies != null) { // find the \"user\" cookie for (int i=0; i&lt;cookies.length; ++i) { if (cookies[i].getName().equals(\"user\")) { // validate the cookie value if (Validator.validateRequired(cookies[i].getValue()) { // valid cookie value, continue processing request ... } } } } [8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，請將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +將機密字元轉換成對應的字元實體來過濾指定字串的範例： // Example to filter sensitive data to prevent cross-site scripting public Class Validator { ... public static String filter(String value) { if (value == null) { return null; } StringBuffer result = new StringBuffer(value.length()); for (int i=0; i&lt;value.length(); ++i) { switch (value.charAt(i)) { case '&lt;': result.append(\"&lt;\"); break; case '&gt;': result.append(\"&gt;\"); break; case '\"': result.append(\"\"\"); break; case '\\'': result.append(\"'\"); break; case '%': result.append(\"%\"); break; case ';': result.append(\";\"); break; case '(': result.append(\"(\"); break; case ')': result.append(\")\"); break; case '&amp;': result.append(\"&amp;\"); break; case '+': result.append(\"+\"); break; default: result.append(value.charAt(i)); break; } return result; } ... } ... // Filter the HTTP response using Validator.filter PrintWriter out = response.getWriter(); // set output response out.write(Validator.filter(response)); out.close(); Java Servlet API 2.3 引進了「過濾器」，它支援截取及轉換 HTTP 要求或回應。利用「Servlet 過濾器」，以 Validator.filter 來消毒回應的範例： // Example to filter all sensitive characters in the HTTP response using a Java Filter. // This example is for illustration purposes since it will filter all content in the response, including HTML tags! public class SensitiveCharsFilter implements Filter { ... public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { PrintWriter out = response.getWriter(); ResponseWrapper wrapper = new ResponseWrapper((HttpServletResponse)response); chain.doFilter(request, wrapper); CharArrayWriter caw = new CharArrayWriter(); caw.write(Validator.filter(wrapper.toString())); response.setContentType(\"text/html\"); response.setContentLength(caw.toString().length()); out.write(caw.toString()); out.close(); } ... public class CharResponseWrapper extends HttpServletResponseWrapper { private CharArrayWriter output; public String toString() { return output.toString(); } public CharResponseWrapper(HttpServletResponse response){ super(response); output = new CharArrayWriter(); } public PrintWriter getWriter(){ return new PrintWriter(output); } } } } [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，請務必利用 Cookie.setSecure（布林旗標），在 HTTP 回應中設定 Cookie 的安全旗標，以指示瀏覽器利用 HTTPS 或 SSL 之類的安全通訊協定來傳送 Cookie。維護 \"user\" Cookie 安全的範例： // Example to secure a cookie, i.e. instruct the browser to // send the cookie using a secure protocol Cookie cookie = new Cookie(\"user\", \"sensitive\"); cookie.setSecure(true); response.addCookie(cookie); 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」實作上述所有資料驗證需求，是一個功能強大的架構。這些規則配置在定義表單欄位輸入驗證規則的 XML 檔中。依預設，Struts 支援在利用 Struts 'bean:write' 標籤撰寫的所有資料上，過濾 [8] HTTP 回應中輸出的危險字元。設定 'filter=false' 旗標可以停用這個過濾。Struts 定義下列基本輸入驗證器，但也可以定義自訂驗證器：required：如果欄位含有空格以外的任何字元，便告成功。mask：如果值符合 mask 屬性給定的正規表示式，便告成功。range：如果值在 min 和 max 屬性給定的值範圍內（(value &gt;= min) 且 (value &lt;= max)），便告成功。maxLength：如果欄位長度小於或等於 max 屬性，便告成功。minLength：如果欄位長度大於或等於 min 屬性，便告成功。byte、short、integer、long、float、double：如果值可以轉換成對應的基本類型，便告成功。date：如果值代表有效日期，便告成功。可提供日期型樣。creditCard：如果值可能是有效的信用卡號碼，便告成功。e-mail：如果值可能是有效的電子郵件位址，便告成功。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件及驗證輸入的 Java API (JSR 127)。JavaServer Faces API 實作下列基本驗證器，但可以定義自訂驗證器：validate_doublerange：登錄元件的 DoubleRangeValidator。validate_length：登錄元件的 LengthValidator。validate_longrange：登錄元件的 LongRangeValidator。validate_required：登錄元件的 RequiredValidator。validate_stringrange：登錄元件的 StringRangeValidator。validator：登錄元件的自訂 Validator。JavaServer Faces API 定義下列 UIInput 和 UIOutput 展現器（標籤）：input_date：接受以 java.text.Date 實例格式化的 java.util.Date。output_date：顯示以 java.text.Date 實例格式化的 java.util.Date。input_datetime：接受以 java.text.Time 實例格式化的 java.util.Date。output_datetime：顯示以 java.text.Time 實例格式化的 java.util.Date。input_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）。output_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）。input_text：接受單行字串。output_text：顯示單行字串。input_time：接受以 java.text.DateFormat 時間實例格式化的 java.util.Date。output_time：顯示以 java.text.DateFormat 時間實例格式化的 java.util.Date。input_hidden：可讓頁面作者將隱藏變數併入頁面。input_secret：接受不含空格的單行文字，並在輸入時，將它顯示成一組星號。input_textarea：接受多行文字。output_errors：顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息。output_label：將巢狀元件顯示為指定輸入欄位的標籤。output_message：顯示本地化訊息。利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 檔案路徑驗證：PHP 提供了一些先驗證檔名再開啟檔案的方法。例如：[1] file_exists() 方法：這個方法檢查檔案或目錄是否存在。如果檔案或目錄存在，它會傳回 True，否則，傳回 False。 &lt;?php $filename = '/path/to/foo.txt'; if (file_exists($filename)) { echo \"The file $filename exists\"; } else { echo \"The file $filename does not exist\"; } ?&gt; [2] is_file() 方法：這個方法指出檔名是否為一般檔案，若是，便傳回 True。 &lt;?php $filename = '/path/to/foo.txt'; if (is_file($filename)) { echo \"The file $filename is a regular file\"; } else { echo \"There is a problem with the file: $filename\"; } ?&gt; [3] 當執行含有使用者輸入的檔案作業時，您應該一律檢查指定的檔名和路徑是否符合特定限制。具體地說，您應該確定只允許在預定的目錄樹狀結構內執行檔案作業。檢查給定的路徑名稱是否開始於所要的目錄名稱並不足夠， 因為攻擊者可以利用路徑遍訪攻擊來欺騙應用程式，讓它在所要的目錄之外提供檔案；比方說，利用 \"../../../../\"（附註：這個字串也可以用許多不同形式來編碼，以略過字串相符演算法）。以下是試圖驗證使用者提供的檔名時，可能會有用的兩個 PHP 函數：realpath() - 傳回標準化絕對路徑名稱basename() - 傳回路徑的檔名元件參照[1] PHP 手冊 - realpath(): http://www.php.net/realpath[2] PHP 手冊 - basename(): http://www.php.net/basename[3] PHP 手冊 - file_exists(): http://www.php.net/file_exists[4] PHP 手冊 - is_file(): http://www.php.net/is_file**檔案路徑驗證：PHP 提供了一些先驗證檔名再開啟檔案的方法。例如：[1] file_exists() 方法：這個方法檢查檔案或目錄是否存在。如果檔案或目錄存在，它會傳回 True，否則，傳回 False。 &lt;?php $filename = '/path/to/foo.txt'; if (file_exists($filename)) { echo \"The file $filename exists\"; } else { echo \"The file $filename does not exist\"; } ?&gt; [2] is_file() 方法：這個方法指出檔名是否為一般檔案，若是，便傳回 True。 &lt;?php $filename = '/path/to/foo.txt'; if (is_file($filename)) { echo \"The file $filename is a regular file\"; } else { echo \"There is a problem with the file: $filename\"; } ?&gt; [3] 當執行含有使用者輸入的檔案作業時，您應該一律檢查指定的檔名和路徑是否符合特定限制。具體地說，您應該確定只允許在預定的目錄樹狀結構內執行檔案作業。檢查給定的路徑名稱是否開始於所要的目錄名稱並不足夠， 因為攻擊者可以利用路徑遍訪攻擊來欺騙應用程式，讓它在所要的目錄之外提供檔案；比方說，利用 \"../../../../\"（附註：這個字串也可以用許多不同形式來編碼，以略過字串相符演算法）。以下是試圖驗證使用者提供的檔名時，可能會有用的兩個 PHP 函數：realpath() - 傳回標準化絕對路徑名稱basename() - 傳回路徑的檔名元件參照[1] PHP 手冊 - realpath(): http://www.php.net/realpath[2] PHP 手冊 - basename(): http://www.php.net/basename[3] PHP 手冊 - file_exists(): http://www.php.net/file_exists[4] PHP 手冊 - is_file(): http://www.php.net/is_file** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但一律必須在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是實作一或多個驗證各個應用程式參數的函數。下列各節說明一些檢查範例。[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // PHP example to validate required fields function validateRequired($input) { ... $pass = false; if (strlen(trim($input))&gt;0){ $pass = true; } return $pass; ... } ... if (validateRequired($fieldName)) { // fieldName is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。[4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。[5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。請一律對照函數需求所定義容許的選項來驗證所選的使用者值。[6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]+$[7] Cookie 值依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。[8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，開發人員應該將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +PHP 包括一些 htmlentities() 之類的自動化消毒公用程式函數： $input = htmlentities($input, ENT_QUOTES, 'UTF-8'); 此外，為了避免「跨網站指令碼」的 UTF-7 變式，您應該明確定義回應的 Content-Type 標頭，例如： &lt;?php header('Content-Type: text/html; charset=UTF-8'); ?&gt; [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，且透過 SSL 來傳輸它時，請務必先在 HTTP 回應中設定 Cookie 的安全旗標。這會指示瀏覽器只透過 SSL 連線來使用這個 Cookie。您可以利用下列程式碼範例來維護 Cookie 安全： &lt;$php $value = \"some_value\"; $time = time()+3600; $path = \"/application/\"; $domain = \".example.com\"; $secure = 1; setcookie(\"CookieName\", $value, $time, $path, $domain, $secure, TRUE); ?&gt; 此外，我們建議您使用 HttpOnly 旗標。當 HttpOnly 旗標設為 TRUE 時，只能透過 HTTP 通訊協定來存取 Cookie。這表示無法用 JavaScript 之類的 Scripting 語言存取 Cookie。這個設定有助於實際減少透過 XSS 攻擊來盜用身分的情況（不過，並非所有瀏覽器都支援）。PHP 5.2.0 新增 HttpOnly 旗標。參照[1] 利用「HTTP 專用 Cookie」緩和「跨網站指令碼」： http://msdn2.microsoft.com/en-us/library/ms533046.aspx[2] PHP 安全聯盟： http://phpsec.org/[3] PHP &amp; Web 應用程式安全部落格 (Chris Shiflett)： http://shiflett.org/<w:br w:type=\"page\"/>"
        },
        {
            "name": "有弱點的元件",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "中",
            "cvss": "5.6",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "CVE-2014-4078",
            "url": "http://testasp.vulnweb.com/",
            "entity": "IIS 8.5 (Component)",
            "risk": "攻擊者有可能使用 Web 伺服器來攻擊其他網站，讓其身分更加隱密\n",
            "cause": "未安裝協力廠商產品的最新修補程式或緊急修復程式",
            "solution": "將元件升級到最新穩定版本",
            "mark": "",
            "solution_description": "有弱點的元件可能導致應用程式出現各種弱點",
            "solution_suggest": "升級到該組件的最新版本。如果該組件已達到其生命終結（EOL），請用最近支持的替代品替換該組件。我們強烈建議聯繫該產品的供應商，看看是否最近有補丁或修復可用。<w:br w:type=\"page\"/>"
        },
        {
            "name": "偵測到隱藏目錄",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "cgi-bin/ (Page)",
            "risk": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站\n",
            "cause": "使用不安全的方式配置 Web 伺服器或應用程式伺服器",
            "solution": "對禁止的資源發出「404 - 找不到」回應狀態碼，或將其完全移除",
            "mark": "/cgi-bin/",
            "solution_description": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站Web 應用程式顯現了網站中的目錄。雖然目錄並沒有列出它的內容，但這個資訊可以協助攻擊者對網站展開進一步的攻擊。例如，知道目錄名稱之後，攻擊者便可以猜測它的內容類型，也許還能猜出其中的檔名或其下的子目錄，並嘗試存取它們。內容的機密性愈高，這個問題也愈嚴重。",
            "solution_suggest": "如果不需要禁止的資源，請將它從網站中移除。可能的話，請發出「404 - 找不到」回應狀態碼，而不是「403 - 禁止」。這項變更會將網站的目錄模糊化，可以防止洩漏網站結構。<w:br w:type=\"page\"/>"
        },
        {
            "name": "偵測到隱藏目錄",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "html/ (Page)",
            "risk": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站\n",
            "cause": "使用不安全的方式配置 Web 伺服器或應用程式伺服器",
            "solution": "對禁止的資源發出「404 - 找不到」回應狀態碼，或將其完全移除",
            "mark": "/html/",
            "solution_description": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站Web 應用程式顯現了網站中的目錄。雖然目錄並沒有列出它的內容，但這個資訊可以協助攻擊者對網站展開進一步的攻擊。例如，知道目錄名稱之後，攻擊者便可以猜測它的內容類型，也許還能猜出其中的檔名或其下的子目錄，並嘗試存取它們。內容的機密性愈高，這個問題也愈嚴重。",
            "solution_suggest": "如果不需要禁止的資源，請將它從網站中移除。可能的話，請發出「404 - 找不到」回應狀態碼，而不是「403 - 禁止」。這項變更會將網站的目錄模糊化，可以防止洩漏網站結構。<w:br w:type=\"page\"/>"
        },
        {
            "name": "偵測到隱藏目錄",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "templates/ (Page)",
            "risk": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站\n",
            "cause": "使用不安全的方式配置 Web 伺服器或應用程式伺服器",
            "solution": "對禁止的資源發出「404 - 找不到」回應狀態碼，或將其完全移除",
            "mark": "/templates/",
            "solution_description": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站Web 應用程式顯現了網站中的目錄。雖然目錄並沒有列出它的內容，但這個資訊可以協助攻擊者對網站展開進一步的攻擊。例如，知道目錄名稱之後，攻擊者便可以猜測它的內容類型，也許還能猜出其中的檔名或其下的子目錄，並嘗試存取它們。內容的機密性愈高，這個問題也愈嚴重。",
            "solution_suggest": "如果不需要禁止的資源，請將它從網站中移除。可能的話，請發出「404 - 找不到」回應狀態碼，而不是「403 - 禁止」。這項變更會將網站的目錄模糊化，可以防止洩漏網站結構。<w:br w:type=\"page\"/>"
        },
        {
            "name": "偵測到隱藏目錄",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "images/ (Page)",
            "risk": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站\n",
            "cause": "使用不安全的方式配置 Web 伺服器或應用程式伺服器",
            "solution": "對禁止的資源發出「404 - 找不到」回應狀態碼，或將其完全移除",
            "mark": "/images/",
            "solution_description": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站Web 應用程式顯現了網站中的目錄。雖然目錄並沒有列出它的內容，但這個資訊可以協助攻擊者對網站展開進一步的攻擊。例如，知道目錄名稱之後，攻擊者便可以猜測它的內容類型，也許還能猜出其中的檔名或其下的子目錄，並嘗試存取它們。內容的機密性愈高，這個問題也愈嚴重。",
            "solution_suggest": "如果不需要禁止的資源，請將它從網站中移除。可能的話，請發出「404 - 找不到」回應狀態碼，而不是「403 - 禁止」。這項變更會將網站的目錄模糊化，可以防止洩漏網站結構。<w:br w:type=\"page\"/>"
        },
        {
            "name": "偵測到隱藏目錄",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "aspnet_client/ (Page)",
            "risk": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站\n",
            "cause": "使用不安全的方式配置 Web 伺服器或應用程式伺服器",
            "solution": "對禁止的資源發出「404 - 找不到」回應狀態碼，或將其完全移除",
            "mark": "/aspnet_client/",
            "solution_description": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站Web 應用程式顯現了網站中的目錄。雖然目錄並沒有列出它的內容，但這個資訊可以協助攻擊者對網站展開進一步的攻擊。例如，知道目錄名稱之後，攻擊者便可以猜測它的內容類型，也許還能猜出其中的檔名或其下的子目錄，並嘗試存取它們。內容的機密性愈高，這個問題也愈嚴重。",
            "solution_suggest": "如果不需要禁止的資源，請將它從網站中移除。可能的話，請發出「404 - 找不到」回應狀態碼，而不是「403 - 禁止」。這項變更會將網站的目錄模糊化，可以防止洩漏網站結構。<w:br w:type=\"page\"/>"
        },
        {
            "name": "偵測到隱藏目錄",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "_vti_cnf/ (Page)",
            "risk": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站\n",
            "cause": "使用不安全的方式配置 Web 伺服器或應用程式伺服器",
            "solution": "對禁止的資源發出「404 - 找不到」回應狀態碼，或將其完全移除",
            "mark": "/_vti_cnf/",
            "solution_description": "有可能擷取網站檔案系統結構的相關資訊，其可能會幫助攻擊者對映網站Web 應用程式顯現了網站中的目錄。雖然目錄並沒有列出它的內容，但這個資訊可以協助攻擊者對網站展開進一步的攻擊。例如，知道目錄名稱之後，攻擊者便可以猜測它的內容類型，也許還能猜出其中的檔名或其下的子目錄，並嘗試存取它們。內容的機密性愈高，這個問題也愈嚴重。",
            "solution_suggest": "如果不需要禁止的資源，請將它從網站中移除。可能的話，請發出「404 - 找不到」回應狀態碼，而不是「403 - 禁止」。這項變更會將網站的目錄模糊化，可以防止洩漏網站結構。<w:br w:type=\"page\"/>"
        },
        {
            "name": "在階段作業 Cookie 中遺漏 HttpOnly 屬性",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "ASPSESSIONIDSQRQRDTS (Cookie)",
            "risk": "有可能竊取或操作客戶階段作業和 Cookie，並可能用來假冒合法的使用者，讓駭客可以檢視或變更使用者記錄，以及用該使用者的身分來執行交易\n",
            "cause": "Web 應用程式設定的階段作業 Cookie 不含 HttpOnly 屬性",
            "solution": "新增 'HttpOnly' 屬性至所有階段作業 Cookie",
            "mark": "",
            "solution_description": "有可能竊取或操作客戶階段作業和 Cookie，其可能用來假冒合法的使用者，讓駭客可以檢視或變更使用者記錄，以及以該使用者的身分來執行交易在應用程式測試期間，偵測到所測試的 Web 應用程式設定了不含 \"HttpOnly\" 屬性的階段作業 Cookie。由於這個階段作業 Cookie 不含 \"HttpOnly\" 屬性，因此其可由注入網站的惡意 Script 來存取，值也可能被竊取。儲存在階段作業記號中的任何資訊都可能被竊取，之後再用來盜用身分或模擬使用者。",
            "solution_suggest": "基本上，Cookie 的唯一必要屬性是 \"name\" 欄位。常見的選用屬性如下：\"comment\"、\"domain\"、\"path\" 等等。\"HttpOnly\" 屬性必須相應地設定，才能防止 Script 存取階段作業 Cookie。<w:br w:type=\"page\"/>"
        },
        {
            "name": "在階段作業 Cookie 中遺漏 HttpOnly 屬性",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "ASPSESSIONIDQQQQQDST (Cookie)",
            "risk": "有可能竊取或操作客戶階段作業和 Cookie，並可能用來假冒合法的使用者，讓駭客可以檢視或變更使用者記錄，以及用該使用者的身分來執行交易\n",
            "cause": "Web 應用程式設定的階段作業 Cookie 不含 HttpOnly 屬性",
            "solution": "新增 'HttpOnly' 屬性至所有階段作業 Cookie",
            "mark": "",
            "solution_description": "有可能竊取或操作客戶階段作業和 Cookie，其可能用來假冒合法的使用者，讓駭客可以檢視或變更使用者記錄，以及以該使用者的身分來執行交易在應用程式測試期間，偵測到所測試的 Web 應用程式設定了不含 \"HttpOnly\" 屬性的階段作業 Cookie。由於這個階段作業 Cookie 不含 \"HttpOnly\" 屬性，因此其可由注入網站的惡意 Script 來存取，值也可能被竊取。儲存在階段作業記號中的任何資訊都可能被竊取，之後再用來盜用身分或模擬使用者。",
            "solution_suggest": "基本上，Cookie 的唯一必要屬性是 \"name\" 欄位。常見的選用屬性如下：\"comment\"、\"domain\"、\"path\" 等等。\"HttpOnly\" 屬性必須相應地設定，才能防止 Script 存取階段作業 Cookie。<w:br w:type=\"page\"/>"
        },
        {
            "name": "應用程式中找到不必要的 HTTP 回應標頭",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "testasp.vulnweb.com (Page)",
            "risk": "有可能收集 Web 應用程式相關的機密性資訊，如：使用者名稱、密碼、機器名稱及/或機密檔案位置\n",
            "cause": "不安全的 Web 應用程式設計或配置",
            "solution": "請勿容許機密性資訊洩漏。",
            "mark": "",
            "solution_description": "可以收集關於 Web 伺服器類型、版本、作業系統等機密資訊。AppScan 偵測到不必要的 Http 回應標頭。基於安全性和隱私考量，\"Server\"、\"X-Powered-By\"、\"X-AspNetMvc-Version\" 和 \"X-AspNet-Version\" 等 Http 回應標頭不應顯示在網頁中。每當由伺服器向用戶端傳送回應時，預設通常會新增 \"Server\" 標頭。每當由伺服器向用戶端傳送回應時，預設可能會新增 \"X-Powered-By\" 標頭。這些新增的標頭可能會顯示與內部伺服器軟體版本與類型相關的機密資訊，讓攻擊者將其複製，並透過目標惡意探索進行攻擊。此外，當新的惡意探索為人所知時，伺服器最有可能會遭到其攻擊。",
            "solution_suggest": "設定您的伺服器，以避免預設的 \"Server\" 標頭傳送至所有傳出要求。若為 IIS，請參閱：https://techcommunity.microsoft.com/t5/iis-support-blog/remove-unwanted-http-response-headers/ba-p/369710若為 nginx，請參閱： https://www.getpagespeed.com/server-setup/nginx/how-to-remove-the-server-header-in-nginx若為 Weblogic，請參閱：https://docs.oracle.com/cd/E13222_01/wls/docs81/adminguide/web_server.html若為 Apache，請參閱： https://techglimpse.com/set-modify-response-headers-http-tip/<w:br w:type=\"page\"/>"
        },
        {
            "name": "缺少加密",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "testasp.vulnweb.com (Page)",
            "risk": "有可能竊取以未加密方式傳送的機密資料，如：信用卡號碼、社會保險號碼等等\n",
            "cause": "機密性輸入欄位（如：使用者名稱、密碼和信用卡號碼）傳遞時未加密",
            "solution": "設定 TLS/SSL 以確保將通訊加密。",
            "mark": "",
            "solution_description": "任何以明碼形式傳送至伺服器的資訊都可能透過網路進行竊取，並在稍後用於身分竊取或使用者模擬。可能可以截取到以未加密形式傳送的機密資料，例如 使用者登入資訊（使用者名稱和密碼）、信用卡號碼、社會保險號碼等。可能可以執行攔截式 (MitM) 攻擊，讓攻擊者完全控制通訊，包括變更內容、竊取資料，或向伺服器模擬使用者。",
            "solution_suggest": "您應該一律只透過 TLS/SSL 連線來傳輸所有資料。這包括所有外部通訊，例如瀏覽器、資料庫這類後端連線、第三方 API 及其他服務。此外，還有數個隱私規範指出一律會將使用者認證這類機密性資訊以加密形式傳送至網站。一律強制使用加密連線（例如 TLS/SSL），而且不容許使用未加密 HTTP 對機密性資訊進行任何存取。使用 TLS 1.2 或 TLS 1.3，以及使用高度加密雜湊演算法和密碼組合。<w:br w:type=\"page\"/>"
        },
        {
            "name": "遺漏「Content-Security-Policy」標頭",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "testasp.vulnweb.com (Page)",
            "risk": "有可能收集 Web 應用程式相關的機密性資訊，如：使用者名稱、密碼、機器名稱及/或機密檔案位置\n有可能說服無經驗而易受騙的使用者提供機密性資訊，如：使用者名稱、密碼、信用卡號碼、社會保險號碼等等\n",
            "cause": "不安全的 Web 應用程式設計或配置",
            "solution": "配置伺服器利用安全原則使用 \"Content-Security-Policy\" 標頭",
            "mark": "",
            "solution_description": "有可能收集 Web 應用程式相關的機密性資訊，如：使用者名稱、密碼、機器名稱及/或機密檔案位置有可能讓無經驗而易受騙的使用者信以為真而提供機密資訊，例如：使用者名稱、密碼、信用卡號碼、社會保險號碼等等缺少 CSP 或設定不適當的值，可能會導致 Web 應用程式遭受 XSS、點擊劫持等攻擊。「Content-Security-Policy」標頭的目的在於修改瀏覽器呈現頁面的方式，進而預防各種跨網站注入攻擊，包括跨網站 跨網站指令碼。請務必設定正確的標頭值，避免網站運作不良。例如，如果將標頭設定為禁止執行行內 JavaScript，網站就不能在頁面中使用行內 JavaScript。為了抵禦跨網站指令碼、跨框架 Scripting 及點擊劫持，請務必設定以下原則並提供適當的值：「default-src」和「frame-ancestors」原則兩者，*或*「script-src」、「object-src」及「frame-ancestors」原則三者。對於「default-src」、「script-src」及「object-src」，請避免「*」、「data:」、「unsafe-inline」或「unsafe-eval」這類不安全的值。對於「frame-ancestors」，請避免「*」或「data:」這類不安全的值。此外，對於「script-src」和「default-src」（「script-src」的後援指引），一般認為「self」是不安全的，應避免使用。如需詳細資訊，請參考以下鏈結。請注意，「Content-Security-Policy」包含四個不同的測試。有個一般測試會驗證「Content-Security-Policy」標頭是否正在使用中，其他三個測試會檢查「Frame-Ancestors」、「Object-Src」和「Script-Src」是否正確設定。",
            "solution_suggest": "設定您的伺服器以傳送「Content-Security-Policy」標頭。建議您將 Content-Security-Policy 標頭設定為其指引的安全值，如下所示：對於「default-src」和「script-src」，安全值包括「none」或 https://any.example.com。對於「frame-ancestors」和「object-src」，預期的安全值包括「self」、「none」或 https://any.example.com 等。「unsafe-inline」和「unsafe-eval」絕不能使用。使用暫時 / 雜湊只能是短期替代方案。若為 Apache 伺服器，請參閱：http://httpd.apache.org/docs/2.2/mod/mod_headers.html若為 IIS 伺服器，請參閱：https://technet.microsoft.com/pl-pl/library/cc753133%28v=ws.10%29.aspx若為 nginx 伺服器，請參閱：http://nginx.org/en/docs/http/ngx_http_headers_module.html<w:br w:type=\"page\"/>"
        },
        {
            "name": "遺漏或不安全的 \"X-Content-Type-Options\" 標頭",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "低",
            "cvss": "3.7",
            "cvss_vector": "AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "testasp.vulnweb.com (Page)",
            "risk": "有可能收集 Web 應用程式相關的機密性資訊，如：使用者名稱、密碼、機器名稱及/或機密檔案位置\n有可能說服無經驗而易受騙的使用者提供機密性資訊，如：使用者名稱、密碼、信用卡號碼、社會保險號碼等等\n",
            "cause": "不安全的 Web 應用程式設計或配置",
            "solution": "配置伺服器利用 \"nosniff\" 值使用 \"X-Content-Type-Options\" 標頭",
            "mark": "",
            "solution_description": "有可能收集 Web 應用程式相關的機密性資訊，如：使用者名稱、密碼、機器名稱及/或機密檔案位置有可能說服無經驗而易受騙的使用者提供機密性資訊，如：使用者名稱、密碼、信用卡號碼、社會保險號碼等等具有 \"nosniff\" 值的 \"X-Content-Type-Options\" 標頭可防止 IE 和 Chrome 忽視回應的內容類型。此動作可防止使用者的瀏覽器（例如在惡意命名後）執行未受信任的內容（例如使用者上傳的內容）。",
            "solution_suggest": "配置您的伺服器，在所有送出的要求上使用值為 \"nosniff\" 的 \"X-Content-Type-Options\" 標頭。若為 Apache 伺服器，請參閱：http://httpd.apache.org/docs/2.2/mod/mod_headers.html若為 IIS 伺服器，請參閱：https://technet.microsoft.com/pl-pl/library/cc753133%28v=ws.10%29.aspx若為 nginx 伺服器，請參閱：http://nginx.org/en/docs/http/ngx_http_headers_module.html<w:br w:type=\"page\"/>"
        },
        {
            "name": "應用程式錯誤",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "參考資訊",
            "cvss": "0.0",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/Search.asp",
            "entity": "tfSearch (Parameter)",
            "risk": "有可能收集機密性除錯資訊\n",
            "cause": "未對送入的參數值執行適當的範圍檢查未執行驗證，以確定使用者輸入符合預期的資料類型",
            "solution": "請驗證參數值是在預期的範圍內且為預期的類型。請勿輸出除錯錯誤訊息和異常狀況",
            "mark": "tfSearch=\\'",
            "solution_description": "有可能收集機密性除錯資訊如果攻擊者偽造含有非應用程式所預期的參數或參數值（範例如下）來探測應用程式，應用程式可能會陷入容易遭到攻擊的未定義狀態。攻擊者可以從應用程式對這項要求的回應中，取得有用的資訊；這項資訊可能會遭到不當運用，從而找出應用程式的弱點。比方說，如果參數欄位應該是單引號括住的字串（例如：在 ASP Script 或 SQL 查詢中），注入的單引號會提早終止字串串流，從而變更 Script 的正常流程/語法。錯誤訊息顯露重要資訊的另一個原因，是 Scripting 引擎、Web 伺服器或資料庫配置錯誤。以下是一些不同的變式：[1] 移除參數[2] 移除參數值[3] 將參數值設為空值[4] 將參數值設為數值溢位 (+/- 99999999)[5] 將參數值設為 ' \" \\' \\\" ) ; 之類的危險字元[6] 將某字串附加到數值參數值[7] 將 \".\"（句號）或 \"[]\"（角括弧）附加至參數名稱",
            "solution_suggest": "[1] 檢查送入要求，以瞭解所有預期的參數和值是否存在。當遺漏參數時，便發出適當的錯誤訊息，或使用預設值。[2] 應用程式應該驗證它的輸入是否由有效字元組成（解碼之後）。例如，含有空值位元組的輸入值（編碼為 %00）、單引號、引號等，都應該予以拒絕。[3] 施行符合預期範圍和類型的值。如果您的應用程式預期特定參數有特定值集中的值，應用程式應該確定它接收的值確實屬於這個值集。比方說，如果您的應用程式預期 10..99 範圍內的值，它應該確定值確實是數值，且在 10..99 範圍內。[4] 確認資料屬於提供給用戶端的資料集。[5] 不在正式作業環境中，輸出除錯錯誤訊息和異常狀況。如果要在 ASP.NET 中停用除錯，請編輯您的 web.config 檔，使它含有下列內容：&lt;compilationdebug=\"false\"/&gt;如需相關資訊，請參閱「如何：停用 ASP.NET 應用程式除錯」，位置如下：http://support.microsoft.com/default.aspx?scid=kb;en-us;815157您可以利用驗證控制項，將輸入驗證新增到「Web 表單」頁面中。驗證控制項提供適用於標準驗證之所有一般類型的簡易使用機制（例如：測試日期是否有效，或值是否在範圍內），以及用來提供自訂編寫驗證的方式。此外，驗證控制項也可讓您完整自訂向使用者顯示錯誤資訊的方式。驗證控制項可以搭配「Web 表單」頁面類別檔所處理的任何控制項來使用，其中包括 HTML 和 Web 伺服器控制項。如果要確定要求含有所有必要的參數，請使用 \"RequiredFieldValidator\" 驗證控制項。這個控制項可確保使用者未跳過 Web 表單中的任何項目。如果要確定使用者輸入只包含有效值，您可以使用下列其中一個驗證控制項：[1] \"RangeValidator\"：檢查使用者的輸入（值）是否在指定的上下界限之間。您可以檢查數字、英文字母和日期之配對內的範圍。[2] \"RegularExpressionValidator\"：檢查輸入是否符合正規表示式所定義的型樣。這類型的驗證可讓您檢查可預期的字元序列，例如：社會保險號碼、電子郵件位址、電話號碼、郵遞區號等等中的字元序列。重要注意事項：驗證控制項不會封鎖使用者輸入，或變更頁面處理流程；它們只會設定錯誤狀態，以及產生錯誤訊息。在執行進一步的應用程式專屬動作之前，程式設計師負責測試程式碼中的控制項狀態。檢查使用者輸入有效性有兩種方式：1. 測試一般錯誤狀態：在您的程式碼中，測試頁面的 IsValid 內容。這個內容會累積頁面上所有驗證控制項的 IsValid 內容值（使用邏輯 AND）。如果其中一個驗證控制項設為無效，頁面內容便會傳回 False。2. 測試個別控制項的錯誤狀態：在迴圈中處理頁面的驗證器集合，集合中含有指向所有驗證控制項的參照。之後，您便可以檢查每個驗證控制項的 IsValid 內容。** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但必須利用 Servlet，在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是在 \"Validator\" 公用程式類別中將上述常式當作靜態方法來實作。下列各節說明範例驗證器類別[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // Java example to validate required fields public Class Validator { ... public static boolean validateRequired(String value) { boolean isFieldValid = false; if (value != null &amp;&amp; value.trim().length() &gt; 0) { isFieldValid = true; } return isFieldValid; } ... } ... String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateRequired(fieldValue)) { // fieldValue is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。請利用 Java 基本封套類別來檢查欄位值是否能安全轉換成所需要的基本資料類型。如何驗證數值欄位（int 類型）的範例： // Java example to validate that a field is an int number public Class Validator { ... public static boolean validateInt(String value) { boolean isFieldValid = false; try { Integer.parseInt(value); isFieldValid = true; } catch (Exception e) { isFieldValid = false; } return isFieldValid; } ... } ... // check if the HTTP request parameter is of type int String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // fieldValue is valid, continue processing request ... } 在實務中，好的做法是將所有 HTTP 要求參數轉換成它們的相關資料類型。例如，將要求參數的 \"integerValue\" 儲存在要求屬性中，再依照下列範例所示來使用它： // Example to convert the HTTP request parameter to a primitive wrapper data type // and store this value in a request attribute for further processing String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // convert fieldValue to an Integer Integer integerValue = Integer.getInteger(fieldValue); // store integerValue in a request attribute request.setAttribute(\"fieldName\", integerValue); } ... // Use the request attribute for further processing Integer integerValue = (Integer)request.getAttribute(\"fieldName\"); ... 應用程式應該處理的主要 Java 資料類型：- Byte- Short- Integer- Long- Float- Double- Date[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。驗證 userName 欄位的長度是否在 8-20 個字元之間的範例： // Example to validate the field length public Class Validator { ... public static boolean validateLength(String value, int minLength, int maxLength) { String validatedValue = value; if (!validateRequired(value)) { validatedValue = \"\"; } return (validatedValue.length() &gt;= minLength &amp;&amp; validatedValue.length() &lt;= maxLength); } ... } ... String userName = request.getParameter(\"userName\"); if (Validator.validateRequired(userName)) { if (Validator.validateLength(userName, 8, 20)) { // userName is valid, continue further processing ... } } [4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。驗證輸入 numberOfChoices 是否在 10-20 之間的範例： // Example to validate the field range public Class Validator { ... public static boolean validateRange(int value, int min, int max) { return (value &gt;= min &amp;&amp; value &lt;= max); } ... } ... String fieldValue = request.getParameter(\"numberOfChoices\"); if (Validator.validateRequired(fieldValue)) { if (Validator.validateInt(fieldValue)) { int numberOfChoices = Integer.parseInt(fieldValue); if (Validator.validateRange(numberOfChoices, 10, 20)) { // numberOfChoices is valid, continue processing request ... } } } [5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。一律檢查使用者輸入是否符合功能需求所定義的型樣。對照容許的選項清單來驗證使用者選項的範例： // Example to validate user selection against a list of options public Class Validator { ... public static boolean validateOption(Object[] options, Object value) { boolean isValidValue = false; try { List list = Arrays.asList(options); if (list != null) { isValidValue = list.contains(value); } } catch (Exception e) { } return isValidValue; } ... } ... // Allowed options String[] options = {\"option1\", \"option2\", \"option3\"); // Verify that the user selection is one of the allowed options String userSelection = request.getParameter(\"userSelection\"); if (Validator.validateOption(options, userSelection)) { // valid user selection, continue processing request ... } [6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]*$Java 1.3 或更早的版本不包括任何正規表示式套件。建議搭配 Java 1.3 來使用「Apache 正規表示式套件」（請參閱下列「資源」），以解決這項支援欠缺。執行正規表示式驗證的範例： // Example to validate that a given value matches a specified pattern // using the Apache regular expression package import org.apache.regexp.RE; import org.apache.regexp.RESyntaxException; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { RE r = new RE(expression); match = r.match(value); } return match; } ... } ... // Verify that the userName request parameter is alpha-numeric String userName = request.getParameter(\"userName\"); if (Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { // userName is valid, continue processing request ... } Java 1.4 引進了新的正規表示式套件 (java.util.regex)。以下是 Validator.matchPattern 的修正版，使用新的 Java 1.4 正規表示式套件： // Example to validate that a given value matches a specified pattern // using the Java 1.4 regular expression package import java.util.regex.Pattern; import java.util.regexe.Matcher; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { match = Pattern.matches(expression, value); } return match; } ... } [7] Cookie 值請利用 javax.servlet.http.Cookie 物件來驗證 Cookie 值。依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。驗證必要 Cookie 值的範例： // Example to validate a required cookie value // First retrieve all available cookies submitted in the HTTP request Cookie[] cookies = request.getCookies(); if (cookies != null) { // find the \"user\" cookie for (int i=0; i&lt;cookies.length; ++i) { if (cookies[i].getName().equals(\"user\")) { // validate the cookie value if (Validator.validateRequired(cookies[i].getValue()) { // valid cookie value, continue processing request ... } } } } [8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，請將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +將機密字元轉換成對應的字元實體來過濾指定字串的範例： // Example to filter sensitive data to prevent cross-site scripting public Class Validator { ... public static String filter(String value) { if (value == null) { return null; } StringBuffer result = new StringBuffer(value.length()); for (int i=0; i&lt;value.length(); ++i) { switch (value.charAt(i)) { case '&lt;': result.append(\"&lt;\"); break; case '&gt;': result.append(\"&gt;\"); break; case '\"': result.append(\"\"\"); break; case '\\'': result.append(\"'\"); break; case '%': result.append(\"%\"); break; case ';': result.append(\";\"); break; case '(': result.append(\"(\"); break; case ')': result.append(\")\"); break; case '&amp;': result.append(\"&amp;\"); break; case '+': result.append(\"+\"); break; default: result.append(value.charAt(i)); break; } return result; } ... } ... // Filter the HTTP response using Validator.filter PrintWriter out = response.getWriter(); // set output response out.write(Validator.filter(response)); out.close(); Java Servlet API 2.3 引進了「過濾器」，它支援截取及轉換 HTTP 要求或回應。利用「Servlet 過濾器」，以 Validator.filter 來消毒回應的範例： // Example to filter all sensitive characters in the HTTP response using a Java Filter. // This example is for illustration purposes since it will filter all content in the response, including HTML tags! public class SensitiveCharsFilter implements Filter { ... public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { PrintWriter out = response.getWriter(); ResponseWrapper wrapper = new ResponseWrapper((HttpServletResponse)response); chain.doFilter(request, wrapper); CharArrayWriter caw = new CharArrayWriter(); caw.write(Validator.filter(wrapper.toString())); response.setContentType(\"text/html\"); response.setContentLength(caw.toString().length()); out.write(caw.toString()); out.close(); } ... public class CharResponseWrapper extends HttpServletResponseWrapper { private CharArrayWriter output; public String toString() { return output.toString(); } public CharResponseWrapper(HttpServletResponse response){ super(response); output = new CharArrayWriter(); } public PrintWriter getWriter(){ return new PrintWriter(output); } } } } [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，請務必利用 Cookie.setSecure(boolean flag)，在 HTTP 回應中設定 Cookie 的安全旗標，以指示瀏覽器利用 HTTPS 或 SSL 之類的安全通訊協定來傳送 Cookie。維護 \"user\" Cookie 安全的範例： // Example to secure a cookie, i.e. instruct the browser to // send the cookie using a secure protocol Cookie cookie = new Cookie(\"user\", \"sensitive\"); cookie.setSecure(true); response.addCookie(cookie); 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」實作上述所有資料驗證需求，是一個功能強大的架構。這些規則配置在定義表單欄位輸入驗證規則的 XML 檔中。依預設，Struts 支援在利用 Struts 'bean:write' 標籤撰寫的所有資料上，過濾 [8] HTTP 回應中輸出的危險字元。設定 'filter=false' 旗標可以停用這個過濾。Struts 定義下列基本輸入驗證器，但也可以定義自訂驗證器：required：如果欄位含有空格以外的任何字元，便告成功。mask：如果值符合 mask 屬性給定的正規表示式，便告成功。range：如果值在 min 和 max 屬性給定的值範圍內（(value &gt;= min) 且 (value &lt;= max)），便告成功。maxLength：如果欄位長度小於或等於 max 屬性，便告成功。minLength：如果欄位長度大於或等於 min 屬性，便告成功。byte、short、integer、long、float、double：如果值可以轉換成對應的基本類型，便告成功。date：如果值代表有效日期，便告成功。可提供日期型樣。creditCard：如果值可能是有效的信用卡號碼，便告成功。e-mail：如果值可能是有效的電子郵件位址，便告成功。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件及輸入驗證的 Java API (JSR 127)。JavaServer Faces API 實作下列基本驗證器，但可以定義自訂驗證器：validate_doublerange：登錄元件的 DoubleRangeValidatorvalidate_length：登錄元件的 LengthValidatorvalidate_longrange：登錄元件的 LongRangeValidatorvalidate_required：登錄元件的 RequiredValidatorvalidate_stringrange：登錄元件的 StringRangeValidatorvalidator：登錄元件的自訂 ValidatorJavaServer Faces API 定義下列 UIInput 和 UIOutput 展現器（標籤）：input_date：接受以 java.text.Date 實例格式化的 java.util.Dateoutput_date：顯示以 java.text.Date 實例格式化的 java.util.Dateinput_datetime：接受以 java.text.Time 實例格式化的 java.util.Dateoutput_datetime：顯示以 java.text.Time 實例格式化的 java.util.Dateinput_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）output_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）input_text：接受單行字串。output_text：顯示單行字串。input_time：接受以 java.text.DateFormat 時間實例格式化的 java.util.Dateoutput_time：顯示以 java.text.DateFormat 時間實例格式化的 java.util.Dateinput_hidden：可讓頁面作者將隱藏變數併入頁面input_secret：接受不含空格的單行文字，輸入之時，將它顯示成一組星號input_textarea：接受多行文字output_errors：顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息output_label：將巢狀元件顯示為指定輸入欄位的標籤output_message：顯示本地化訊息利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 錯誤處理：許多 J2EE Web 應用程式架構都遵循「模型視圖控制器 (MVC)」型樣。在這個型樣中，Servlet 扮演控制器的角色。Servlet 將應用程式處理程序委派給 JavaBean，例如，EJB Session Bean（模型）。之後，Servlet 再將要求轉遞給 JSP（視圖）來呈現處理結果。Servlet 應該檢查所有輸入、輸出、回覆碼、錯誤碼及已知的異常狀況，以確保會實際進行預期的處理程序。資料驗證可以保護應用程式免於遭受惡意的資料竄改，有效的錯誤處理策略則是防止應用程式意外揭露內部錯誤訊息（例如：異常狀況堆疊追蹤）所不可或缺。好的錯誤處理策略會處理下列項目：[1] 定義錯誤[2] 報告錯誤[3] 呈現錯誤[4] 錯誤對映[1] 定義錯誤應該避免將錯誤訊息寫在應用程式層（例如：Servlet）。相反地，應用程式應該使用對映至已知之應用程式失敗的錯誤索引鍵。在實務中，好的做法是定義錯誤索引鍵來對映至 HTML 表單欄位或其他 Bean 內容的驗證規則。比方說，如果需要 \"user_name\" 欄位，它必須是英數字元，且在資料庫中必須是唯一，便應該定義下列錯誤索引鍵：(a) ERROR_USERNAME_REQUIRED：這個錯誤索引鍵用來顯示一則訊息，通知使用者需要 \"user_name\" 欄位；(b) ERROR_USERNAME_ALPHANUMERIC：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 欄位應該是英數字元；(c) ERROR_USERNAME_DUPLICATE：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 值在資料庫中重複；(d) ERROR_USERNAME_INVALID：這個錯誤索引鍵用來顯示一則一般訊息，通知使用者 \"user_name\" 值無效；在實務中，好的做法是定義下列架構 Java 類別來儲存及報告應用程式錯誤：- ErrorKeys：定義所有錯誤索引鍵 // Example: ErrorKeys defining the following error keys: // - ERROR_USERNAME_REQUIRED // - ERROR_USERNAME_ALPHANUMERIC // - ERROR_USERNAME_DUPLICATE // - ERROR_USERNAME_INVALID // ... public Class ErrorKeys { public static final String ERROR_USERNAME_REQUIRED = \"error.username.required\"; public static final String ERROR_USERNAME_ALPHANUMERIC = \"error.username.alphanumeric\"; public static final String ERROR_USERNAME_DUPLICATE = \"error.username.duplicate\"; public static final String ERROR_USERNAME_INVALID = \"error.username.invalid\"; ... } - Error：封裝個別錯誤 // Example: Error encapsulates an error key. // Error is serializable to support code executing in multiple JVMs. public Class Error implements Serializable { // Constructor given a specified error key public Error(String key) { this(key, null); } // Constructor given a specified error key and array of placeholder objects public Error(String key, Object[] values) { this.key = key; this.values = values; } // Returns the error key public String getKey() { return this.key; } // Returns the placeholder values public Object[] getValues() { return this.values; } private String key = null; private Object[] values = null; } - Errors：封裝錯誤的集合 // Example: Errors encapsulates the Error objects being reported to the presentation layer. // Errors are stored in a HashMap where the key is the bean property name and value is an // ArrayList of Error objects. public Class Errors implements Serializable { // Adds an Error object to the Collection of errors for the specified bean property. public void addError(String property, Error error) { ArrayList propertyErrors = (ArrayList)errors.get(property); if (propertyErrors == null) { propertyErrors = new ArrayList(); errors.put(property, propertyErrors); } propertyErrors.put(error); } // Returns true if there are any errors public boolean hasErrors() { return (errors.size &gt; 0); } // Returns the Errors for the specified property public ArrayList getErrors(String property) { return (ArrayList)errors.get(property); } private HashMap errors = new HashMap(); } 以下是利用上述架構類別來處理 \"user_name\" 欄位驗證錯誤的範例： // Example to process validation errors of the \"user_name\" field. Errors errors = new Errors(); String userName = request.getParameter(\"user_name\"); // (a) Required validation rule if (!Validator.validateRequired(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_REQUIRED)); } // (b) Alpha-numeric validation rule else if (!Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_ALPHANUMERIC)); } else { // (c) Duplicate check validation rule // We assume that there is an existing UserValidationEJB session bean that implements // a checkIfDuplicate() method to verify if the user already exists in the database. try { ... if (UserValidationEJB.checkIfDuplicate(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE)); } } catch (RemoteException e) { // log the error logger.error(\"Could not validate user for specified userName: \" + userName); errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE); } } // set the errors object in a request attribute called \"errors\" request.setAttribute(\"errors\", errors); ... [2] 報告錯誤報告 Web 層應用程式錯誤的方式有兩種：(a) Servlet 錯誤機制(b) JSP 錯誤機制[2-a] Servlet 錯誤機制Servlet 報告錯誤的可能方式如下：- 轉遞至輸入 JSP（已將錯誤儲存在要求屬性中），或- 利用 HTTP 錯誤碼引數來呼叫 response.sendError，或- 擲出異常狀況在實務中，好的做法是處理所有已知的應用程式錯誤（依照 [1] 區段所說明），將它們儲存在要求屬性中，再轉遞給輸入 JSP。輸入 JSP 應該顯示錯誤訊息，並提示使用者重新輸入資料。下列範例說明如何轉遞到輸入 JSP (userInput.jsp)： // Example to forward to the userInput.jsp following user validation errors RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd != null) { rd.forward(request, response); } 如果 Servlet 無法轉遞到已知的 JSP 頁面，第二個選項是利用 response.sendError 方法，設定 HttpServletResponse.SC_INTERNAL_SERVER_ERROR 引數（狀態碼 500）來報告錯誤。請參閱 javax.servlet.http.HttpServletResponse javadoc，以取得各種 HTTP 狀態碼的詳細資訊。傳回 HTTP 錯誤的範例： // Example to return a HTTP error code RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd == null) { // messages is a resource bundle with all message keys and values response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, messages.getMessage(ErrorKeys.ERROR_USERNAME_INVALID)); } 作為最後的手段，Servlet 可以擲出異常狀況，它必須是下列類別之一的子類別：- RuntimeException- ServletException- IOException[2-b] JSP 錯誤機制 JSP 頁面依照下列範例所示來定義 errorPage 指引，從而提供了執行時期異常狀況的處理機制： &lt;%@ page errorPage=\"/errors/userValidation.jsp\" %&gt; 未捕捉的 JSP 異常狀況是轉遞到指定的 errorPage，而原始異常狀況則設在稱為 javax.servlet.jsp.jspException 的要求參數中。錯誤頁面必須包含 isErrorPage 指引，如下所示： &lt;%@ page isErrorPage=\"true\" %&gt; isErrorPage 指引會使 \"exception\" 變數起始設定為所擲出的異常狀況物件。[3] 呈現錯誤J2SE Internationalization API 提供用來提出應用程式資源以及將訊息格式化的公用程式類別，其中包括：(a) 資源組(b) 訊息格式化[3-a] 資源組資源組會將本地化的資料與使用它的原始碼分開，從而支援國際化。每個資源組都會儲存特定語言環境之鍵值配對的對映。通常是利用或延伸 java.util.PropertyResourceBundle，它會將內容儲存在外部內容檔中，如下列範例所示： ################################################ # ErrorMessages.properties ################################################ # required user name error message error.username.required=User name field is required # invalid user name format error.username.alphanumeric=User name must be alphanumeric # duplicate user name error message error.username.duplicate=User name {0} already exists, please choose another one ... 定義多重資源可以支援不同的語言環境（因此稱為資源組）。例如，定義 ErrorMessages_fr.properties 可以支援資源組系列的法國成員。如果要求之語言環境的資源成員不存在，便會使用預設成員。在上述範例中，預設資源是 ErrorMessages.properties。在上述範例中，預設資源是 ErrorMessages.properties。依使用者的語言環境而定，應用程式（JSP 或 Servlet）會從適當的資源擷取內容。[3-b] 訊息格式化J2SE 標準類別 java.util.MessageFormat 提供以取代位置保留元來建立訊息的一般方式。MessageFormat 物件包含內嵌了格式指定元的型樣字串，如下所示： // Example to show how to format a message using placeholder parameters String pattern = \"User name {0} already exists, please choose another one\"; String userName = request.getParameter(\"user_name\"); Object[] args = new Object[1]; args[0] = userName; String message = MessageFormat.format(pattern, args); 以下是利用 ResourceBundle 和 MessageFormat 來呈現錯誤訊息的更綜合性的範例： // Example to render an error message from a localized ErrorMessages resource (properties file) // Utility class to retrieve locale-specific error messages public Class ErrorMessageResource { // Returns the error message for the specified error key in the environment locale public String getErrorMessage(String errorKey) { return getErrorMessage(errorKey, defaultLocale); } // Returns the error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Locale locale) { return getErrorMessage(errorKey, null, locale); } // Returns a formatted error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Object[] args, Locale locale) { // Get localized ErrorMessageResource ResourceBundle errorMessageResource = ResourceBundle.getBundle(\"ErrorMessages\", locale); // Get localized error message String errorMessage = errorMessageResource.getString(errorKey); if (args != null) { // Format the message using the specified placeholders args return MessageFormat.format(errorMessage, args); } else { return errorMessage; } } // default environment locale private Locale defaultLocale = Locale.getDefaultLocale(); } ... // Get the user's locale Locale userLocale = request.getLocale(); // Check if there were any validation errors Errors errors = (Errors)request.getAttribute(\"errors\"); if (errors != null &amp;&amp; errors.hasErrors()) { // iterate through errors and output error messages corresponding to the \"user_name\" property ArrayList userNameErrors = errors.getErrors(\"user_name\"); ListIterator iterator = userNameErrors.iterator(); while (iterator.hasNext()) { // Get the next error object Error error = (Error)iterator.next(); String errorMessage = ErrorMessageResource.getErrorMessage(error.getKey(), userLocale); output.write(errorMessage + \"\\r\\n\"); } } 建議您定義自訂 JSP 標籤（如 displayErrors）來疊代處理及呈現錯誤訊息，如上述範例所示。[4] 錯誤對映一般而言，「Servlet 儲存器」會傳回對應於回應狀態碼或異常狀況的預設錯誤頁面。您可以利用自訂錯誤頁面來指定狀態碼或異常狀況與 Web 資源之間的對映。在實務中，好的做法是開發不揭露內部錯誤狀態的靜態錯誤頁面（依預設，大部分 Servlet 儲存器都會報告內部錯誤訊息）。這項對映是依照下列範例所指定，配置在「Web 部署描述子 (web.xml)」中： &lt;!-- Mapping of HTTP error codes and application exceptions to error pages --&gt; &lt;error-page&gt; &lt;exception-type&gt;UserValidationException&lt;/exception-type&gt; &lt;location&gt;/errors/validationError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/exception-type&gt; &lt;location&gt;/errors/internalError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; ... &lt;/error-page&gt; ... 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」是依照上述說明來定義錯誤處理機制的 Java 架構。驗證規則配置在 XML 檔中，檔案定義了表單欄位的輸入驗證規則以及對應的驗證錯誤索引鍵。Struts 提供國際化支援，供您利用資源組和訊息格式化來建置本地化應用程式。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; Struts JSP 標籤庫定義了有條件地顯示一組累計錯誤訊息的 \"errors\" 標籤，如下列範例所示： &lt;%@ page language=\"java\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-html.tld\" prefix=\"html\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-bean.tld\" prefix=\"bean\" %&gt; &lt;html:html&gt; &lt;head&gt; &lt;body&gt; &lt;html:form action=\"/logon.do\"&gt; &lt;table border=\"0\" width=\"100%\"&gt; &lt;tr&gt; &lt;th align=\"right\"&gt; &lt;html:errors property=\"username\"/&gt; &lt;bean:message key=\"prompt.username\"/&gt; &lt;/th&gt; &lt;td align=\"left\"&gt; &lt;html:text property=\"username\" size=\"16\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt; &lt;html:submit&gt;&lt;bean:message key=\"button.submit\"/&gt;&lt;/html:submit&gt; &lt;/td&gt; &lt;td align=\"right\"&gt; &lt;html:reset&gt;&lt;bean:message key=\"button.reset\"/&gt;&lt;/html:reset&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/html:form&gt; &lt;/body&gt; &lt;/html:html&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件、驗證輸入，以及支援國際化的 Java API (JSR 127)。JavaServer Faces API 定義了 \"output_errors\" UIOutput 展現器，以顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息。利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但一律必須在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是實作一或多個驗證各個應用程式參數的函數。下列各節說明一些檢查範例。[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // PHP example to validate required fields function validateRequired($input) { ... $pass = false; if (strlen(trim($input))&gt;0){ $pass = true; } return $pass; ... } ... if (validateRequired($fieldName)) { // fieldName is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。[4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。[5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。一律檢查使用者輸入是否符合功能需求所定義的型樣。[6] 欄位型樣 一律檢查使用者輸入是否符合功能需求所定義的型樣。 比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]+$[7] Cookie 值依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。[8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，開發人員應該將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +PHP 包括一些 htmlentities() 之類的自動化消毒公用程式函數： $input = htmlentities($input, ENT_QUOTES, 'UTF-8'); 此外，為了避免「跨網站指令碼」的 UTF-7 變式，您應該明確定義回應的 Content-Type 標頭，例如： &lt;?php header('Content-Type: text/html; charset=UTF-8'); ?&gt; [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，且透過 SSL 來傳輸它時，請務必先在 HTTP 回應中設定 Cookie 的安全旗標。這會指示瀏覽器只透過 SSL 連線來使用這個 Cookie。您可以利用下列程式碼範例來維護 Cookie 安全： &lt;$php $value = \"some_value\"; $time = time()+3600; $path = \"/application/\"; $domain = \".example.com\"; $secure = 1; setcookie(\"CookieName\", $value, $time, $path, $domain, $secure, TRUE); ?&gt; 此外，我們建議您使用 HttpOnly 旗標。當 HttpOnly 旗標設為 TRUE 時，只能透過 HTTP 通訊協定來存取 Cookie。這表示無法用 JavaScript 之類的 Scripting 語言存取 Cookie。這個設定有助於實際減少透過 XSS 攻擊來盜用身分的情況（不過，並非所有瀏覽器都支援）。PHP 5.2.0 新增 HttpOnly 旗標。參照[1] 利用「HTTP 專用 Cookie」緩和「跨網站指令碼」：http://msdn2.microsoft.com/en-us/library/ms533046.aspx[2] PHP 安全聯盟：http://phpsec.org/[3] PHP &amp; Web 應用程式安全部落格 (Chris Shiflett)： http://shiflett.org/<w:br w:type=\"page\"/>"
        },
        {
            "name": "應用程式錯誤",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "參考資訊",
            "cvss": "0.0",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/Templatize.asp",
            "entity": "item (Parameter)",
            "risk": "有可能收集機密性除錯資訊\n",
            "cause": "未對送入的參數值執行適當的範圍檢查未執行驗證，以確定使用者輸入符合預期的資料類型",
            "solution": "請驗證參數值是在預期的範圍內且為預期的類型。請勿輸出除錯錯誤訊息和異常狀況",
            "mark": "item=%00",
            "solution_description": "有可能收集機密性除錯資訊如果攻擊者偽造含有非應用程式所預期的參數或參數值（範例如下）來探測應用程式，應用程式可能會陷入容易遭到攻擊的未定義狀態。攻擊者可以從應用程式對這項要求的回應中，取得有用的資訊；這項資訊可能會遭到不當運用，從而找出應用程式的弱點。比方說，如果參數欄位應該是單引號括住的字串（例如：在 ASP Script 或 SQL 查詢中），注入的單引號會提早終止字串串流，從而變更 Script 的正常流程/語法。錯誤訊息顯露重要資訊的另一個原因，是 Scripting 引擎、Web 伺服器或資料庫配置錯誤。以下是一些不同的變式：[1] 移除參數[2] 移除參數值[3] 將參數值設為空值[4] 將參數值設為數值溢位 (+/- 99999999)[5] 將參數值設為 ' \" \\' \\\" ) ; 之類的危險字元[6] 將某字串附加到數值參數值[7] 將 \".\"（句號）或 \"[]\"（角括弧）附加至參數名稱",
            "solution_suggest": "[1] 檢查送入要求，以瞭解所有預期的參數和值是否存在。當遺漏參數時，便發出適當的錯誤訊息，或使用預設值。[2] 應用程式應該驗證它的輸入是否由有效字元組成（解碼之後）。例如，含有空值位元組的輸入值（編碼為 %00）、單引號、引號等，都應該予以拒絕。[3] 施行符合預期範圍和類型的值。如果您的應用程式預期特定參數有特定值集中的值，應用程式應該確定它接收的值確實屬於這個值集。比方說，如果您的應用程式預期 10..99 範圍內的值，它應該確定值確實是數值，且在 10..99 範圍內。[4] 確認資料屬於提供給用戶端的資料集。[5] 不在正式作業環境中，輸出除錯錯誤訊息和異常狀況。如果要在 ASP.NET 中停用除錯，請編輯您的 web.config 檔，使它含有下列內容：&lt;compilationdebug=\"false\"/&gt;如需相關資訊，請參閱「如何：停用 ASP.NET 應用程式除錯」，位置如下：http://support.microsoft.com/default.aspx?scid=kb;en-us;815157您可以利用驗證控制項，將輸入驗證新增到「Web 表單」頁面中。驗證控制項提供適用於標準驗證之所有一般類型的簡易使用機制（例如：測試日期是否有效，或值是否在範圍內），以及用來提供自訂編寫驗證的方式。此外，驗證控制項也可讓您完整自訂向使用者顯示錯誤資訊的方式。驗證控制項可以搭配「Web 表單」頁面類別檔所處理的任何控制項來使用，其中包括 HTML 和 Web 伺服器控制項。如果要確定要求含有所有必要的參數，請使用 \"RequiredFieldValidator\" 驗證控制項。這個控制項可確保使用者未跳過 Web 表單中的任何項目。如果要確定使用者輸入只包含有效值，您可以使用下列其中一個驗證控制項：[1] \"RangeValidator\"：檢查使用者的輸入（值）是否在指定的上下界限之間。您可以檢查數字、英文字母和日期之配對內的範圍。[2] \"RegularExpressionValidator\"：檢查輸入是否符合正規表示式所定義的型樣。這類型的驗證可讓您檢查可預期的字元序列，例如：社會保險號碼、電子郵件位址、電話號碼、郵遞區號等等中的字元序列。重要注意事項：驗證控制項不會封鎖使用者輸入，或變更頁面處理流程；它們只會設定錯誤狀態，以及產生錯誤訊息。在執行進一步的應用程式專屬動作之前，程式設計師負責測試程式碼中的控制項狀態。檢查使用者輸入有效性有兩種方式：1. 測試一般錯誤狀態：在您的程式碼中，測試頁面的 IsValid 內容。這個內容會累積頁面上所有驗證控制項的 IsValid 內容值（使用邏輯 AND）。如果其中一個驗證控制項設為無效，頁面內容便會傳回 False。2. 測試個別控制項的錯誤狀態：在迴圈中處理頁面的驗證器集合，集合中含有指向所有驗證控制項的參照。之後，您便可以檢查每個驗證控制項的 IsValid 內容。** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但必須利用 Servlet，在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是在 \"Validator\" 公用程式類別中將上述常式當作靜態方法來實作。下列各節說明範例驗證器類別[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // Java example to validate required fields public Class Validator { ... public static boolean validateRequired(String value) { boolean isFieldValid = false; if (value != null &amp;&amp; value.trim().length() &gt; 0) { isFieldValid = true; } return isFieldValid; } ... } ... String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateRequired(fieldValue)) { // fieldValue is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。請利用 Java 基本封套類別來檢查欄位值是否能安全轉換成所需要的基本資料類型。如何驗證數值欄位（int 類型）的範例： // Java example to validate that a field is an int number public Class Validator { ... public static boolean validateInt(String value) { boolean isFieldValid = false; try { Integer.parseInt(value); isFieldValid = true; } catch (Exception e) { isFieldValid = false; } return isFieldValid; } ... } ... // check if the HTTP request parameter is of type int String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // fieldValue is valid, continue processing request ... } 在實務中，好的做法是將所有 HTTP 要求參數轉換成它們的相關資料類型。例如，將要求參數的 \"integerValue\" 儲存在要求屬性中，再依照下列範例所示來使用它： // Example to convert the HTTP request parameter to a primitive wrapper data type // and store this value in a request attribute for further processing String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // convert fieldValue to an Integer Integer integerValue = Integer.getInteger(fieldValue); // store integerValue in a request attribute request.setAttribute(\"fieldName\", integerValue); } ... // Use the request attribute for further processing Integer integerValue = (Integer)request.getAttribute(\"fieldName\"); ... 應用程式應該處理的主要 Java 資料類型：- Byte- Short- Integer- Long- Float- Double- Date[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。驗證 userName 欄位的長度是否在 8-20 個字元之間的範例： // Example to validate the field length public Class Validator { ... public static boolean validateLength(String value, int minLength, int maxLength) { String validatedValue = value; if (!validateRequired(value)) { validatedValue = \"\"; } return (validatedValue.length() &gt;= minLength &amp;&amp; validatedValue.length() &lt;= maxLength); } ... } ... String userName = request.getParameter(\"userName\"); if (Validator.validateRequired(userName)) { if (Validator.validateLength(userName, 8, 20)) { // userName is valid, continue further processing ... } } [4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。驗證輸入 numberOfChoices 是否在 10-20 之間的範例： // Example to validate the field range public Class Validator { ... public static boolean validateRange(int value, int min, int max) { return (value &gt;= min &amp;&amp; value &lt;= max); } ... } ... String fieldValue = request.getParameter(\"numberOfChoices\"); if (Validator.validateRequired(fieldValue)) { if (Validator.validateInt(fieldValue)) { int numberOfChoices = Integer.parseInt(fieldValue); if (Validator.validateRange(numberOfChoices, 10, 20)) { // numberOfChoices is valid, continue processing request ... } } } [5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。一律檢查使用者輸入是否符合功能需求所定義的型樣。對照容許的選項清單來驗證使用者選項的範例： // Example to validate user selection against a list of options public Class Validator { ... public static boolean validateOption(Object[] options, Object value) { boolean isValidValue = false; try { List list = Arrays.asList(options); if (list != null) { isValidValue = list.contains(value); } } catch (Exception e) { } return isValidValue; } ... } ... // Allowed options String[] options = {\"option1\", \"option2\", \"option3\"); // Verify that the user selection is one of the allowed options String userSelection = request.getParameter(\"userSelection\"); if (Validator.validateOption(options, userSelection)) { // valid user selection, continue processing request ... } [6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]*$Java 1.3 或更早的版本不包括任何正規表示式套件。建議搭配 Java 1.3 來使用「Apache 正規表示式套件」（請參閱下列「資源」），以解決這項支援欠缺。執行正規表示式驗證的範例： // Example to validate that a given value matches a specified pattern // using the Apache regular expression package import org.apache.regexp.RE; import org.apache.regexp.RESyntaxException; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { RE r = new RE(expression); match = r.match(value); } return match; } ... } ... // Verify that the userName request parameter is alpha-numeric String userName = request.getParameter(\"userName\"); if (Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { // userName is valid, continue processing request ... } Java 1.4 引進了新的正規表示式套件 (java.util.regex)。以下是 Validator.matchPattern 的修正版，使用新的 Java 1.4 正規表示式套件： // Example to validate that a given value matches a specified pattern // using the Java 1.4 regular expression package import java.util.regex.Pattern; import java.util.regexe.Matcher; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { match = Pattern.matches(expression, value); } return match; } ... } [7] Cookie 值請利用 javax.servlet.http.Cookie 物件來驗證 Cookie 值。依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。驗證必要 Cookie 值的範例： // Example to validate a required cookie value // First retrieve all available cookies submitted in the HTTP request Cookie[] cookies = request.getCookies(); if (cookies != null) { // find the \"user\" cookie for (int i=0; i&lt;cookies.length; ++i) { if (cookies[i].getName().equals(\"user\")) { // validate the cookie value if (Validator.validateRequired(cookies[i].getValue()) { // valid cookie value, continue processing request ... } } } } [8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，請將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +將機密字元轉換成對應的字元實體來過濾指定字串的範例： // Example to filter sensitive data to prevent cross-site scripting public Class Validator { ... public static String filter(String value) { if (value == null) { return null; } StringBuffer result = new StringBuffer(value.length()); for (int i=0; i&lt;value.length(); ++i) { switch (value.charAt(i)) { case '&lt;': result.append(\"&lt;\"); break; case '&gt;': result.append(\"&gt;\"); break; case '\"': result.append(\"\"\"); break; case '\\'': result.append(\"'\"); break; case '%': result.append(\"%\"); break; case ';': result.append(\";\"); break; case '(': result.append(\"(\"); break; case ')': result.append(\")\"); break; case '&amp;': result.append(\"&amp;\"); break; case '+': result.append(\"+\"); break; default: result.append(value.charAt(i)); break; } return result; } ... } ... // Filter the HTTP response using Validator.filter PrintWriter out = response.getWriter(); // set output response out.write(Validator.filter(response)); out.close(); Java Servlet API 2.3 引進了「過濾器」，它支援截取及轉換 HTTP 要求或回應。利用「Servlet 過濾器」，以 Validator.filter 來消毒回應的範例： // Example to filter all sensitive characters in the HTTP response using a Java Filter. // This example is for illustration purposes since it will filter all content in the response, including HTML tags! public class SensitiveCharsFilter implements Filter { ... public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { PrintWriter out = response.getWriter(); ResponseWrapper wrapper = new ResponseWrapper((HttpServletResponse)response); chain.doFilter(request, wrapper); CharArrayWriter caw = new CharArrayWriter(); caw.write(Validator.filter(wrapper.toString())); response.setContentType(\"text/html\"); response.setContentLength(caw.toString().length()); out.write(caw.toString()); out.close(); } ... public class CharResponseWrapper extends HttpServletResponseWrapper { private CharArrayWriter output; public String toString() { return output.toString(); } public CharResponseWrapper(HttpServletResponse response){ super(response); output = new CharArrayWriter(); } public PrintWriter getWriter(){ return new PrintWriter(output); } } } } [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，請務必利用 Cookie.setSecure(boolean flag)，在 HTTP 回應中設定 Cookie 的安全旗標，以指示瀏覽器利用 HTTPS 或 SSL 之類的安全通訊協定來傳送 Cookie。維護 \"user\" Cookie 安全的範例： // Example to secure a cookie, i.e. instruct the browser to // send the cookie using a secure protocol Cookie cookie = new Cookie(\"user\", \"sensitive\"); cookie.setSecure(true); response.addCookie(cookie); 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」實作上述所有資料驗證需求，是一個功能強大的架構。這些規則配置在定義表單欄位輸入驗證規則的 XML 檔中。依預設，Struts 支援在利用 Struts 'bean:write' 標籤撰寫的所有資料上，過濾 [8] HTTP 回應中輸出的危險字元。設定 'filter=false' 旗標可以停用這個過濾。Struts 定義下列基本輸入驗證器，但也可以定義自訂驗證器：required：如果欄位含有空格以外的任何字元，便告成功。mask：如果值符合 mask 屬性給定的正規表示式，便告成功。range：如果值在 min 和 max 屬性給定的值範圍內（(value &gt;= min) 且 (value &lt;= max)），便告成功。maxLength：如果欄位長度小於或等於 max 屬性，便告成功。minLength：如果欄位長度大於或等於 min 屬性，便告成功。byte、short、integer、long、float、double：如果值可以轉換成對應的基本類型，便告成功。date：如果值代表有效日期，便告成功。可提供日期型樣。creditCard：如果值可能是有效的信用卡號碼，便告成功。e-mail：如果值可能是有效的電子郵件位址，便告成功。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件及輸入驗證的 Java API (JSR 127)。JavaServer Faces API 實作下列基本驗證器，但可以定義自訂驗證器：validate_doublerange：登錄元件的 DoubleRangeValidatorvalidate_length：登錄元件的 LengthValidatorvalidate_longrange：登錄元件的 LongRangeValidatorvalidate_required：登錄元件的 RequiredValidatorvalidate_stringrange：登錄元件的 StringRangeValidatorvalidator：登錄元件的自訂 ValidatorJavaServer Faces API 定義下列 UIInput 和 UIOutput 展現器（標籤）：input_date：接受以 java.text.Date 實例格式化的 java.util.Dateoutput_date：顯示以 java.text.Date 實例格式化的 java.util.Dateinput_datetime：接受以 java.text.Time 實例格式化的 java.util.Dateoutput_datetime：顯示以 java.text.Time 實例格式化的 java.util.Dateinput_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）output_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）input_text：接受單行字串。output_text：顯示單行字串。input_time：接受以 java.text.DateFormat 時間實例格式化的 java.util.Dateoutput_time：顯示以 java.text.DateFormat 時間實例格式化的 java.util.Dateinput_hidden：可讓頁面作者將隱藏變數併入頁面input_secret：接受不含空格的單行文字，輸入之時，將它顯示成一組星號input_textarea：接受多行文字output_errors：顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息output_label：將巢狀元件顯示為指定輸入欄位的標籤output_message：顯示本地化訊息利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 錯誤處理：許多 J2EE Web 應用程式架構都遵循「模型視圖控制器 (MVC)」型樣。在這個型樣中，Servlet 扮演控制器的角色。Servlet 將應用程式處理程序委派給 JavaBean，例如，EJB Session Bean（模型）。之後，Servlet 再將要求轉遞給 JSP（視圖）來呈現處理結果。Servlet 應該檢查所有輸入、輸出、回覆碼、錯誤碼及已知的異常狀況，以確保會實際進行預期的處理程序。資料驗證可以保護應用程式免於遭受惡意的資料竄改，有效的錯誤處理策略則是防止應用程式意外揭露內部錯誤訊息（例如：異常狀況堆疊追蹤）所不可或缺。好的錯誤處理策略會處理下列項目：[1] 定義錯誤[2] 報告錯誤[3] 呈現錯誤[4] 錯誤對映[1] 定義錯誤應該避免將錯誤訊息寫在應用程式層（例如：Servlet）。相反地，應用程式應該使用對映至已知之應用程式失敗的錯誤索引鍵。在實務中，好的做法是定義錯誤索引鍵來對映至 HTML 表單欄位或其他 Bean 內容的驗證規則。比方說，如果需要 \"user_name\" 欄位，它必須是英數字元，且在資料庫中必須是唯一，便應該定義下列錯誤索引鍵：(a) ERROR_USERNAME_REQUIRED：這個錯誤索引鍵用來顯示一則訊息，通知使用者需要 \"user_name\" 欄位；(b) ERROR_USERNAME_ALPHANUMERIC：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 欄位應該是英數字元；(c) ERROR_USERNAME_DUPLICATE：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 值在資料庫中重複；(d) ERROR_USERNAME_INVALID：這個錯誤索引鍵用來顯示一則一般訊息，通知使用者 \"user_name\" 值無效；在實務中，好的做法是定義下列架構 Java 類別來儲存及報告應用程式錯誤：- ErrorKeys：定義所有錯誤索引鍵 // Example: ErrorKeys defining the following error keys: // - ERROR_USERNAME_REQUIRED // - ERROR_USERNAME_ALPHANUMERIC // - ERROR_USERNAME_DUPLICATE // - ERROR_USERNAME_INVALID // ... public Class ErrorKeys { public static final String ERROR_USERNAME_REQUIRED = \"error.username.required\"; public static final String ERROR_USERNAME_ALPHANUMERIC = \"error.username.alphanumeric\"; public static final String ERROR_USERNAME_DUPLICATE = \"error.username.duplicate\"; public static final String ERROR_USERNAME_INVALID = \"error.username.invalid\"; ... } - Error：封裝個別錯誤 // Example: Error encapsulates an error key. // Error is serializable to support code executing in multiple JVMs. public Class Error implements Serializable { // Constructor given a specified error key public Error(String key) { this(key, null); } // Constructor given a specified error key and array of placeholder objects public Error(String key, Object[] values) { this.key = key; this.values = values; } // Returns the error key public String getKey() { return this.key; } // Returns the placeholder values public Object[] getValues() { return this.values; } private String key = null; private Object[] values = null; } - Errors：封裝錯誤的集合 // Example: Errors encapsulates the Error objects being reported to the presentation layer. // Errors are stored in a HashMap where the key is the bean property name and value is an // ArrayList of Error objects. public Class Errors implements Serializable { // Adds an Error object to the Collection of errors for the specified bean property. public void addError(String property, Error error) { ArrayList propertyErrors = (ArrayList)errors.get(property); if (propertyErrors == null) { propertyErrors = new ArrayList(); errors.put(property, propertyErrors); } propertyErrors.put(error); } // Returns true if there are any errors public boolean hasErrors() { return (errors.size &gt; 0); } // Returns the Errors for the specified property public ArrayList getErrors(String property) { return (ArrayList)errors.get(property); } private HashMap errors = new HashMap(); } 以下是利用上述架構類別來處理 \"user_name\" 欄位驗證錯誤的範例： // Example to process validation errors of the \"user_name\" field. Errors errors = new Errors(); String userName = request.getParameter(\"user_name\"); // (a) Required validation rule if (!Validator.validateRequired(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_REQUIRED)); } // (b) Alpha-numeric validation rule else if (!Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_ALPHANUMERIC)); } else { // (c) Duplicate check validation rule // We assume that there is an existing UserValidationEJB session bean that implements // a checkIfDuplicate() method to verify if the user already exists in the database. try { ... if (UserValidationEJB.checkIfDuplicate(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE)); } } catch (RemoteException e) { // log the error logger.error(\"Could not validate user for specified userName: \" + userName); errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE); } } // set the errors object in a request attribute called \"errors\" request.setAttribute(\"errors\", errors); ... [2] 報告錯誤報告 Web 層應用程式錯誤的方式有兩種：(a) Servlet 錯誤機制(b) JSP 錯誤機制[2-a] Servlet 錯誤機制Servlet 報告錯誤的可能方式如下：- 轉遞至輸入 JSP（已將錯誤儲存在要求屬性中），或- 利用 HTTP 錯誤碼引數來呼叫 response.sendError，或- 擲出異常狀況在實務中，好的做法是處理所有已知的應用程式錯誤（依照 [1] 區段所說明），將它們儲存在要求屬性中，再轉遞給輸入 JSP。輸入 JSP 應該顯示錯誤訊息，並提示使用者重新輸入資料。下列範例說明如何轉遞到輸入 JSP (userInput.jsp)： // Example to forward to the userInput.jsp following user validation errors RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd != null) { rd.forward(request, response); } 如果 Servlet 無法轉遞到已知的 JSP 頁面，第二個選項是利用 response.sendError 方法，設定 HttpServletResponse.SC_INTERNAL_SERVER_ERROR 引數（狀態碼 500）來報告錯誤。請參閱 javax.servlet.http.HttpServletResponse javadoc，以取得各種 HTTP 狀態碼的詳細資訊。傳回 HTTP 錯誤的範例： // Example to return a HTTP error code RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd == null) { // messages is a resource bundle with all message keys and values response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, messages.getMessage(ErrorKeys.ERROR_USERNAME_INVALID)); } 作為最後的手段，Servlet 可以擲出異常狀況，它必須是下列類別之一的子類別：- RuntimeException- ServletException- IOException[2-b] JSP 錯誤機制 JSP 頁面依照下列範例所示來定義 errorPage 指引，從而提供了執行時期異常狀況的處理機制： &lt;%@ page errorPage=\"/errors/userValidation.jsp\" %&gt; 未捕捉的 JSP 異常狀況是轉遞到指定的 errorPage，而原始異常狀況則設在稱為 javax.servlet.jsp.jspException 的要求參數中。錯誤頁面必須包含 isErrorPage 指引，如下所示： &lt;%@ page isErrorPage=\"true\" %&gt; isErrorPage 指引會使 \"exception\" 變數起始設定為所擲出的異常狀況物件。[3] 呈現錯誤J2SE Internationalization API 提供用來提出應用程式資源以及將訊息格式化的公用程式類別，其中包括：(a) 資源組(b) 訊息格式化[3-a] 資源組資源組會將本地化的資料與使用它的原始碼分開，從而支援國際化。每個資源組都會儲存特定語言環境之鍵值配對的對映。通常是利用或延伸 java.util.PropertyResourceBundle，它會將內容儲存在外部內容檔中，如下列範例所示： ################################################ # ErrorMessages.properties ################################################ # required user name error message error.username.required=User name field is required # invalid user name format error.username.alphanumeric=User name must be alphanumeric # duplicate user name error message error.username.duplicate=User name {0} already exists, please choose another one ... 定義多重資源可以支援不同的語言環境（因此稱為資源組）。例如，定義 ErrorMessages_fr.properties 可以支援資源組系列的法國成員。如果要求之語言環境的資源成員不存在，便會使用預設成員。在上述範例中，預設資源是 ErrorMessages.properties。在上述範例中，預設資源是 ErrorMessages.properties。依使用者的語言環境而定，應用程式（JSP 或 Servlet）會從適當的資源擷取內容。[3-b] 訊息格式化J2SE 標準類別 java.util.MessageFormat 提供以取代位置保留元來建立訊息的一般方式。MessageFormat 物件包含內嵌了格式指定元的型樣字串，如下所示： // Example to show how to format a message using placeholder parameters String pattern = \"User name {0} already exists, please choose another one\"; String userName = request.getParameter(\"user_name\"); Object[] args = new Object[1]; args[0] = userName; String message = MessageFormat.format(pattern, args); 以下是利用 ResourceBundle 和 MessageFormat 來呈現錯誤訊息的更綜合性的範例： // Example to render an error message from a localized ErrorMessages resource (properties file) // Utility class to retrieve locale-specific error messages public Class ErrorMessageResource { // Returns the error message for the specified error key in the environment locale public String getErrorMessage(String errorKey) { return getErrorMessage(errorKey, defaultLocale); } // Returns the error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Locale locale) { return getErrorMessage(errorKey, null, locale); } // Returns a formatted error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Object[] args, Locale locale) { // Get localized ErrorMessageResource ResourceBundle errorMessageResource = ResourceBundle.getBundle(\"ErrorMessages\", locale); // Get localized error message String errorMessage = errorMessageResource.getString(errorKey); if (args != null) { // Format the message using the specified placeholders args return MessageFormat.format(errorMessage, args); } else { return errorMessage; } } // default environment locale private Locale defaultLocale = Locale.getDefaultLocale(); } ... // Get the user's locale Locale userLocale = request.getLocale(); // Check if there were any validation errors Errors errors = (Errors)request.getAttribute(\"errors\"); if (errors != null &amp;&amp; errors.hasErrors()) { // iterate through errors and output error messages corresponding to the \"user_name\" property ArrayList userNameErrors = errors.getErrors(\"user_name\"); ListIterator iterator = userNameErrors.iterator(); while (iterator.hasNext()) { // Get the next error object Error error = (Error)iterator.next(); String errorMessage = ErrorMessageResource.getErrorMessage(error.getKey(), userLocale); output.write(errorMessage + \"\\r\\n\"); } } 建議您定義自訂 JSP 標籤（如 displayErrors）來疊代處理及呈現錯誤訊息，如上述範例所示。[4] 錯誤對映一般而言，「Servlet 儲存器」會傳回對應於回應狀態碼或異常狀況的預設錯誤頁面。您可以利用自訂錯誤頁面來指定狀態碼或異常狀況與 Web 資源之間的對映。在實務中，好的做法是開發不揭露內部錯誤狀態的靜態錯誤頁面（依預設，大部分 Servlet 儲存器都會報告內部錯誤訊息）。這項對映是依照下列範例所指定，配置在「Web 部署描述子 (web.xml)」中： &lt;!-- Mapping of HTTP error codes and application exceptions to error pages --&gt; &lt;error-page&gt; &lt;exception-type&gt;UserValidationException&lt;/exception-type&gt; &lt;location&gt;/errors/validationError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/exception-type&gt; &lt;location&gt;/errors/internalError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; ... &lt;/error-page&gt; ... 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」是依照上述說明來定義錯誤處理機制的 Java 架構。驗證規則配置在 XML 檔中，檔案定義了表單欄位的輸入驗證規則以及對應的驗證錯誤索引鍵。Struts 提供國際化支援，供您利用資源組和訊息格式化來建置本地化應用程式。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; Struts JSP 標籤庫定義了有條件地顯示一組累計錯誤訊息的 \"errors\" 標籤，如下列範例所示： &lt;%@ page language=\"java\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-html.tld\" prefix=\"html\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-bean.tld\" prefix=\"bean\" %&gt; &lt;html:html&gt; &lt;head&gt; &lt;body&gt; &lt;html:form action=\"/logon.do\"&gt; &lt;table border=\"0\" width=\"100%\"&gt; &lt;tr&gt; &lt;th align=\"right\"&gt; &lt;html:errors property=\"username\"/&gt; &lt;bean:message key=\"prompt.username\"/&gt; &lt;/th&gt; &lt;td align=\"left\"&gt; &lt;html:text property=\"username\" size=\"16\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt; &lt;html:submit&gt;&lt;bean:message key=\"button.submit\"/&gt;&lt;/html:submit&gt; &lt;/td&gt; &lt;td align=\"right\"&gt; &lt;html:reset&gt;&lt;bean:message key=\"button.reset\"/&gt;&lt;/html:reset&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/html:form&gt; &lt;/body&gt; &lt;/html:html&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件、驗證輸入，以及支援國際化的 Java API (JSR 127)。JavaServer Faces API 定義了 \"output_errors\" UIOutput 展現器，以顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息。利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但一律必須在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是實作一或多個驗證各個應用程式參數的函數。下列各節說明一些檢查範例。[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // PHP example to validate required fields function validateRequired($input) { ... $pass = false; if (strlen(trim($input))&gt;0){ $pass = true; } return $pass; ... } ... if (validateRequired($fieldName)) { // fieldName is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。[4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。[5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。一律檢查使用者輸入是否符合功能需求所定義的型樣。[6] 欄位型樣 一律檢查使用者輸入是否符合功能需求所定義的型樣。 比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]+$[7] Cookie 值依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。[8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，開發人員應該將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +PHP 包括一些 htmlentities() 之類的自動化消毒公用程式函數： $input = htmlentities($input, ENT_QUOTES, 'UTF-8'); 此外，為了避免「跨網站指令碼」的 UTF-7 變式，您應該明確定義回應的 Content-Type 標頭，例如： &lt;?php header('Content-Type: text/html; charset=UTF-8'); ?&gt; [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，且透過 SSL 來傳輸它時，請務必先在 HTTP 回應中設定 Cookie 的安全旗標。這會指示瀏覽器只透過 SSL 連線來使用這個 Cookie。您可以利用下列程式碼範例來維護 Cookie 安全： &lt;$php $value = \"some_value\"; $time = time()+3600; $path = \"/application/\"; $domain = \".example.com\"; $secure = 1; setcookie(\"CookieName\", $value, $time, $path, $domain, $secure, TRUE); ?&gt; 此外，我們建議您使用 HttpOnly 旗標。當 HttpOnly 旗標設為 TRUE 時，只能透過 HTTP 通訊協定來存取 Cookie。這表示無法用 JavaScript 之類的 Scripting 語言存取 Cookie。這個設定有助於實際減少透過 XSS 攻擊來盜用身分的情況（不過，並非所有瀏覽器都支援）。PHP 5.2.0 新增 HttpOnly 旗標。參照[1] 利用「HTTP 專用 Cookie」緩和「跨網站指令碼」：http://msdn2.microsoft.com/en-us/library/ms533046.aspx[2] PHP 安全聯盟：http://phpsec.org/[3] PHP &amp; Web 應用程式安全部落格 (Chris Shiflett)： http://shiflett.org/<w:br w:type=\"page\"/>"
        },
        {
            "name": "應用程式錯誤",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "參考資訊",
            "cvss": "0.0",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N/E:X/RL:X/RC:X/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/showthread.asp",
            "entity": "id (Parameter)",
            "risk": "有可能收集機密性除錯資訊\n",
            "cause": "未對送入的參數值執行適當的範圍檢查未執行驗證，以確定使用者輸入符合預期的資料類型",
            "solution": "請驗證參數值是在預期的範圍內且為預期的類型。請勿輸出除錯錯誤訊息和異常狀況",
            "mark": "id=%27",
            "solution_description": "有可能收集機密性除錯資訊如果攻擊者偽造含有非應用程式所預期的參數或參數值（範例如下）來探測應用程式，應用程式可能會陷入容易遭到攻擊的未定義狀態。攻擊者可以從應用程式對這項要求的回應中，取得有用的資訊；這項資訊可能會遭到不當運用，從而找出應用程式的弱點。比方說，如果參數欄位應該是單引號括住的字串（例如：在 ASP Script 或 SQL 查詢中），注入的單引號會提早終止字串串流，從而變更 Script 的正常流程/語法。錯誤訊息顯露重要資訊的另一個原因，是 Scripting 引擎、Web 伺服器或資料庫配置錯誤。以下是一些不同的變式：[1] 移除參數[2] 移除參數值[3] 將參數值設為空值[4] 將參數值設為數值溢位 (+/- 99999999)[5] 將參數值設為 ' \" \\' \\\" ) ; 之類的危險字元[6] 將某字串附加到數值參數值[7] 將 \".\"（句號）或 \"[]\"（角括弧）附加至參數名稱",
            "solution_suggest": "[1] 檢查送入要求，以瞭解所有預期的參數和值是否存在。當遺漏參數時，便發出適當的錯誤訊息，或使用預設值。[2] 應用程式應該驗證它的輸入是否由有效字元組成（解碼之後）。例如，含有空值位元組的輸入值（編碼為 %00）、單引號、引號等，都應該予以拒絕。[3] 施行符合預期範圍和類型的值。如果您的應用程式預期特定參數有特定值集中的值，應用程式應該確定它接收的值確實屬於這個值集。比方說，如果您的應用程式預期 10..99 範圍內的值，它應該確定值確實是數值，且在 10..99 範圍內。[4] 確認資料屬於提供給用戶端的資料集。[5] 不在正式作業環境中，輸出除錯錯誤訊息和異常狀況。如果要在 ASP.NET 中停用除錯，請編輯您的 web.config 檔，使它含有下列內容：&lt;compilationdebug=\"false\"/&gt;如需相關資訊，請參閱「如何：停用 ASP.NET 應用程式除錯」，位置如下：http://support.microsoft.com/default.aspx?scid=kb;en-us;815157您可以利用驗證控制項，將輸入驗證新增到「Web 表單」頁面中。驗證控制項提供適用於標準驗證之所有一般類型的簡易使用機制（例如：測試日期是否有效，或值是否在範圍內），以及用來提供自訂編寫驗證的方式。此外，驗證控制項也可讓您完整自訂向使用者顯示錯誤資訊的方式。驗證控制項可以搭配「Web 表單」頁面類別檔所處理的任何控制項來使用，其中包括 HTML 和 Web 伺服器控制項。如果要確定要求含有所有必要的參數，請使用 \"RequiredFieldValidator\" 驗證控制項。這個控制項可確保使用者未跳過 Web 表單中的任何項目。如果要確定使用者輸入只包含有效值，您可以使用下列其中一個驗證控制項：[1] \"RangeValidator\"：檢查使用者的輸入（值）是否在指定的上下界限之間。您可以檢查數字、英文字母和日期之配對內的範圍。[2] \"RegularExpressionValidator\"：檢查輸入是否符合正規表示式所定義的型樣。這類型的驗證可讓您檢查可預期的字元序列，例如：社會保險號碼、電子郵件位址、電話號碼、郵遞區號等等中的字元序列。重要注意事項：驗證控制項不會封鎖使用者輸入，或變更頁面處理流程；它們只會設定錯誤狀態，以及產生錯誤訊息。在執行進一步的應用程式專屬動作之前，程式設計師負責測試程式碼中的控制項狀態。檢查使用者輸入有效性有兩種方式：1. 測試一般錯誤狀態：在您的程式碼中，測試頁面的 IsValid 內容。這個內容會累積頁面上所有驗證控制項的 IsValid 內容值（使用邏輯 AND）。如果其中一個驗證控制項設為無效，頁面內容便會傳回 False。2. 測試個別控制項的錯誤狀態：在迴圈中處理頁面的驗證器集合，集合中含有指向所有驗證控制項的參照。之後，您便可以檢查每個驗證控制項的 IsValid 內容。** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但必須利用 Servlet，在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是在 \"Validator\" 公用程式類別中將上述常式當作靜態方法來實作。下列各節說明範例驗證器類別[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // Java example to validate required fields public Class Validator { ... public static boolean validateRequired(String value) { boolean isFieldValid = false; if (value != null &amp;&amp; value.trim().length() &gt; 0) { isFieldValid = true; } return isFieldValid; } ... } ... String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateRequired(fieldValue)) { // fieldValue is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。請利用 Java 基本封套類別來檢查欄位值是否能安全轉換成所需要的基本資料類型。如何驗證數值欄位（int 類型）的範例： // Java example to validate that a field is an int number public Class Validator { ... public static boolean validateInt(String value) { boolean isFieldValid = false; try { Integer.parseInt(value); isFieldValid = true; } catch (Exception e) { isFieldValid = false; } return isFieldValid; } ... } ... // check if the HTTP request parameter is of type int String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // fieldValue is valid, continue processing request ... } 在實務中，好的做法是將所有 HTTP 要求參數轉換成它們的相關資料類型。例如，將要求參數的 \"integerValue\" 儲存在要求屬性中，再依照下列範例所示來使用它： // Example to convert the HTTP request parameter to a primitive wrapper data type // and store this value in a request attribute for further processing String fieldValue = request.getParameter(\"fieldName\"); if (Validator.validateInt(fieldValue)) { // convert fieldValue to an Integer Integer integerValue = Integer.getInteger(fieldValue); // store integerValue in a request attribute request.setAttribute(\"fieldName\", integerValue); } ... // Use the request attribute for further processing Integer integerValue = (Integer)request.getAttribute(\"fieldName\"); ... 應用程式應該處理的主要 Java 資料類型：- Byte- Short- Integer- Long- Float- Double- Date[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。驗證 userName 欄位的長度是否在 8-20 個字元之間的範例： // Example to validate the field length public Class Validator { ... public static boolean validateLength(String value, int minLength, int maxLength) { String validatedValue = value; if (!validateRequired(value)) { validatedValue = \"\"; } return (validatedValue.length() &gt;= minLength &amp;&amp; validatedValue.length() &lt;= maxLength); } ... } ... String userName = request.getParameter(\"userName\"); if (Validator.validateRequired(userName)) { if (Validator.validateLength(userName, 8, 20)) { // userName is valid, continue further processing ... } } [4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。驗證輸入 numberOfChoices 是否在 10-20 之間的範例： // Example to validate the field range public Class Validator { ... public static boolean validateRange(int value, int min, int max) { return (value &gt;= min &amp;&amp; value &lt;= max); } ... } ... String fieldValue = request.getParameter(\"numberOfChoices\"); if (Validator.validateRequired(fieldValue)) { if (Validator.validateInt(fieldValue)) { int numberOfChoices = Integer.parseInt(fieldValue); if (Validator.validateRange(numberOfChoices, 10, 20)) { // numberOfChoices is valid, continue processing request ... } } } [5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。一律檢查使用者輸入是否符合功能需求所定義的型樣。對照容許的選項清單來驗證使用者選項的範例： // Example to validate user selection against a list of options public Class Validator { ... public static boolean validateOption(Object[] options, Object value) { boolean isValidValue = false; try { List list = Arrays.asList(options); if (list != null) { isValidValue = list.contains(value); } } catch (Exception e) { } return isValidValue; } ... } ... // Allowed options String[] options = {\"option1\", \"option2\", \"option3\"); // Verify that the user selection is one of the allowed options String userSelection = request.getParameter(\"userSelection\"); if (Validator.validateOption(options, userSelection)) { // valid user selection, continue processing request ... } [6] 欄位型樣一律檢查使用者輸入是否符合功能需求所定義的型樣。比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]*$Java 1.3 或更早的版本不包括任何正規表示式套件。建議搭配 Java 1.3 來使用「Apache 正規表示式套件」（請參閱下列「資源」），以解決這項支援欠缺。執行正規表示式驗證的範例： // Example to validate that a given value matches a specified pattern // using the Apache regular expression package import org.apache.regexp.RE; import org.apache.regexp.RESyntaxException; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { RE r = new RE(expression); match = r.match(value); } return match; } ... } ... // Verify that the userName request parameter is alpha-numeric String userName = request.getParameter(\"userName\"); if (Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { // userName is valid, continue processing request ... } Java 1.4 引進了新的正規表示式套件 (java.util.regex)。以下是 Validator.matchPattern 的修正版，使用新的 Java 1.4 正規表示式套件： // Example to validate that a given value matches a specified pattern // using the Java 1.4 regular expression package import java.util.regex.Pattern; import java.util.regexe.Matcher; public Class Validator { ... public static boolean matchPattern(String value, String expression) { boolean match = false; if (validateRequired(expression)) { match = Pattern.matches(expression, value); } return match; } ... } [7] Cookie 值請利用 javax.servlet.http.Cookie 物件來驗證 Cookie 值。依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。驗證必要 Cookie 值的範例： // Example to validate a required cookie value // First retrieve all available cookies submitted in the HTTP request Cookie[] cookies = request.getCookies(); if (cookies != null) { // find the \"user\" cookie for (int i=0; i&lt;cookies.length; ++i) { if (cookies[i].getName().equals(\"user\")) { // validate the cookie value if (Validator.validateRequired(cookies[i].getValue()) { // valid cookie value, continue processing request ... } } } } [8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，請將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +將機密字元轉換成對應的字元實體來過濾指定字串的範例： // Example to filter sensitive data to prevent cross-site scripting public Class Validator { ... public static String filter(String value) { if (value == null) { return null; } StringBuffer result = new StringBuffer(value.length()); for (int i=0; i&lt;value.length(); ++i) { switch (value.charAt(i)) { case '&lt;': result.append(\"&lt;\"); break; case '&gt;': result.append(\"&gt;\"); break; case '\"': result.append(\"\"\"); break; case '\\'': result.append(\"'\"); break; case '%': result.append(\"%\"); break; case ';': result.append(\";\"); break; case '(': result.append(\"(\"); break; case ')': result.append(\")\"); break; case '&amp;': result.append(\"&amp;\"); break; case '+': result.append(\"+\"); break; default: result.append(value.charAt(i)); break; } return result; } ... } ... // Filter the HTTP response using Validator.filter PrintWriter out = response.getWriter(); // set output response out.write(Validator.filter(response)); out.close(); Java Servlet API 2.3 引進了「過濾器」，它支援截取及轉換 HTTP 要求或回應。利用「Servlet 過濾器」，以 Validator.filter 來消毒回應的範例： // Example to filter all sensitive characters in the HTTP response using a Java Filter. // This example is for illustration purposes since it will filter all content in the response, including HTML tags! public class SensitiveCharsFilter implements Filter { ... public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { PrintWriter out = response.getWriter(); ResponseWrapper wrapper = new ResponseWrapper((HttpServletResponse)response); chain.doFilter(request, wrapper); CharArrayWriter caw = new CharArrayWriter(); caw.write(Validator.filter(wrapper.toString())); response.setContentType(\"text/html\"); response.setContentLength(caw.toString().length()); out.write(caw.toString()); out.close(); } ... public class CharResponseWrapper extends HttpServletResponseWrapper { private CharArrayWriter output; public String toString() { return output.toString(); } public CharResponseWrapper(HttpServletResponse response){ super(response); output = new CharArrayWriter(); } public PrintWriter getWriter(){ return new PrintWriter(output); } } } } [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，請務必利用 Cookie.setSecure(boolean flag)，在 HTTP 回應中設定 Cookie 的安全旗標，以指示瀏覽器利用 HTTPS 或 SSL 之類的安全通訊協定來傳送 Cookie。維護 \"user\" Cookie 安全的範例： // Example to secure a cookie, i.e. instruct the browser to // send the cookie using a secure protocol Cookie cookie = new Cookie(\"user\", \"sensitive\"); cookie.setSecure(true); response.addCookie(cookie); 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」實作上述所有資料驗證需求，是一個功能強大的架構。這些規則配置在定義表單欄位輸入驗證規則的 XML 檔中。依預設，Struts 支援在利用 Struts 'bean:write' 標籤撰寫的所有資料上，過濾 [8] HTTP 回應中輸出的危險字元。設定 'filter=false' 旗標可以停用這個過濾。Struts 定義下列基本輸入驗證器，但也可以定義自訂驗證器：required：如果欄位含有空格以外的任何字元，便告成功。mask：如果值符合 mask 屬性給定的正規表示式，便告成功。range：如果值在 min 和 max 屬性給定的值範圍內（(value &gt;= min) 且 (value &lt;= max)），便告成功。maxLength：如果欄位長度小於或等於 max 屬性，便告成功。minLength：如果欄位長度大於或等於 min 屬性，便告成功。byte、short、integer、long、float、double：如果值可以轉換成對應的基本類型，便告成功。date：如果值代表有效日期，便告成功。可提供日期型樣。creditCard：如果值可能是有效的信用卡號碼，便告成功。e-mail：如果值可能是有效的電子郵件位址，便告成功。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件及輸入驗證的 Java API (JSR 127)。JavaServer Faces API 實作下列基本驗證器，但可以定義自訂驗證器：validate_doublerange：登錄元件的 DoubleRangeValidatorvalidate_length：登錄元件的 LengthValidatorvalidate_longrange：登錄元件的 LongRangeValidatorvalidate_required：登錄元件的 RequiredValidatorvalidate_stringrange：登錄元件的 StringRangeValidatorvalidator：登錄元件的自訂 ValidatorJavaServer Faces API 定義下列 UIInput 和 UIOutput 展現器（標籤）：input_date：接受以 java.text.Date 實例格式化的 java.util.Dateoutput_date：顯示以 java.text.Date 實例格式化的 java.util.Dateinput_datetime：接受以 java.text.Time 實例格式化的 java.util.Dateoutput_datetime：顯示以 java.text.Time 實例格式化的 java.util.Dateinput_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）output_number：顯示以 java.text.NumberFormat 格式化的數值資料類型（java.lang.Number 或基本資料類型）input_text：接受單行字串。output_text：顯示單行字串。input_time：接受以 java.text.DateFormat 時間實例格式化的 java.util.Dateoutput_time：顯示以 java.text.DateFormat 時間實例格式化的 java.util.Dateinput_hidden：可讓頁面作者將隱藏變數併入頁面input_secret：接受不含空格的單行文字，輸入之時，將它顯示成一組星號input_textarea：接受多行文字output_errors：顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息output_label：將巢狀元件顯示為指定輸入欄位的標籤output_message：顯示本地化訊息利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 錯誤處理：許多 J2EE Web 應用程式架構都遵循「模型視圖控制器 (MVC)」型樣。在這個型樣中，Servlet 扮演控制器的角色。Servlet 將應用程式處理程序委派給 JavaBean，例如，EJB Session Bean（模型）。之後，Servlet 再將要求轉遞給 JSP（視圖）來呈現處理結果。Servlet 應該檢查所有輸入、輸出、回覆碼、錯誤碼及已知的異常狀況，以確保會實際進行預期的處理程序。資料驗證可以保護應用程式免於遭受惡意的資料竄改，有效的錯誤處理策略則是防止應用程式意外揭露內部錯誤訊息（例如：異常狀況堆疊追蹤）所不可或缺。好的錯誤處理策略會處理下列項目：[1] 定義錯誤[2] 報告錯誤[3] 呈現錯誤[4] 錯誤對映[1] 定義錯誤應該避免將錯誤訊息寫在應用程式層（例如：Servlet）。相反地，應用程式應該使用對映至已知之應用程式失敗的錯誤索引鍵。在實務中，好的做法是定義錯誤索引鍵來對映至 HTML 表單欄位或其他 Bean 內容的驗證規則。比方說，如果需要 \"user_name\" 欄位，它必須是英數字元，且在資料庫中必須是唯一，便應該定義下列錯誤索引鍵：(a) ERROR_USERNAME_REQUIRED：這個錯誤索引鍵用來顯示一則訊息，通知使用者需要 \"user_name\" 欄位；(b) ERROR_USERNAME_ALPHANUMERIC：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 欄位應該是英數字元；(c) ERROR_USERNAME_DUPLICATE：這個錯誤索引鍵用來顯示一則訊息，通知使用者 \"user_name\" 值在資料庫中重複；(d) ERROR_USERNAME_INVALID：這個錯誤索引鍵用來顯示一則一般訊息，通知使用者 \"user_name\" 值無效；在實務中，好的做法是定義下列架構 Java 類別來儲存及報告應用程式錯誤：- ErrorKeys：定義所有錯誤索引鍵 // Example: ErrorKeys defining the following error keys: // - ERROR_USERNAME_REQUIRED // - ERROR_USERNAME_ALPHANUMERIC // - ERROR_USERNAME_DUPLICATE // - ERROR_USERNAME_INVALID // ... public Class ErrorKeys { public static final String ERROR_USERNAME_REQUIRED = \"error.username.required\"; public static final String ERROR_USERNAME_ALPHANUMERIC = \"error.username.alphanumeric\"; public static final String ERROR_USERNAME_DUPLICATE = \"error.username.duplicate\"; public static final String ERROR_USERNAME_INVALID = \"error.username.invalid\"; ... } - Error：封裝個別錯誤 // Example: Error encapsulates an error key. // Error is serializable to support code executing in multiple JVMs. public Class Error implements Serializable { // Constructor given a specified error key public Error(String key) { this(key, null); } // Constructor given a specified error key and array of placeholder objects public Error(String key, Object[] values) { this.key = key; this.values = values; } // Returns the error key public String getKey() { return this.key; } // Returns the placeholder values public Object[] getValues() { return this.values; } private String key = null; private Object[] values = null; } - Errors：封裝錯誤的集合 // Example: Errors encapsulates the Error objects being reported to the presentation layer. // Errors are stored in a HashMap where the key is the bean property name and value is an // ArrayList of Error objects. public Class Errors implements Serializable { // Adds an Error object to the Collection of errors for the specified bean property. public void addError(String property, Error error) { ArrayList propertyErrors = (ArrayList)errors.get(property); if (propertyErrors == null) { propertyErrors = new ArrayList(); errors.put(property, propertyErrors); } propertyErrors.put(error); } // Returns true if there are any errors public boolean hasErrors() { return (errors.size &gt; 0); } // Returns the Errors for the specified property public ArrayList getErrors(String property) { return (ArrayList)errors.get(property); } private HashMap errors = new HashMap(); } 以下是利用上述架構類別來處理 \"user_name\" 欄位驗證錯誤的範例： // Example to process validation errors of the \"user_name\" field. Errors errors = new Errors(); String userName = request.getParameter(\"user_name\"); // (a) Required validation rule if (!Validator.validateRequired(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_REQUIRED)); } // (b) Alpha-numeric validation rule else if (!Validator.matchPattern(userName, \"^[a-zA-Z0-9]*$\")) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_ALPHANUMERIC)); } else { // (c) Duplicate check validation rule // We assume that there is an existing UserValidationEJB session bean that implements // a checkIfDuplicate() method to verify if the user already exists in the database. try { ... if (UserValidationEJB.checkIfDuplicate(userName)) { errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE)); } } catch (RemoteException e) { // log the error logger.error(\"Could not validate user for specified userName: \" + userName); errors.addError(\"user_name\", new Error(ErrorKeys.ERROR_USERNAME_DUPLICATE); } } // set the errors object in a request attribute called \"errors\" request.setAttribute(\"errors\", errors); ... [2] 報告錯誤報告 Web 層應用程式錯誤的方式有兩種：(a) Servlet 錯誤機制(b) JSP 錯誤機制[2-a] Servlet 錯誤機制Servlet 報告錯誤的可能方式如下：- 轉遞至輸入 JSP（已將錯誤儲存在要求屬性中），或- 利用 HTTP 錯誤碼引數來呼叫 response.sendError，或- 擲出異常狀況在實務中，好的做法是處理所有已知的應用程式錯誤（依照 [1] 區段所說明），將它們儲存在要求屬性中，再轉遞給輸入 JSP。輸入 JSP 應該顯示錯誤訊息，並提示使用者重新輸入資料。下列範例說明如何轉遞到輸入 JSP (userInput.jsp)： // Example to forward to the userInput.jsp following user validation errors RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd != null) { rd.forward(request, response); } 如果 Servlet 無法轉遞到已知的 JSP 頁面，第二個選項是利用 response.sendError 方法，設定 HttpServletResponse.SC_INTERNAL_SERVER_ERROR 引數（狀態碼 500）來報告錯誤。請參閱 javax.servlet.http.HttpServletResponse javadoc，以取得各種 HTTP 狀態碼的詳細資訊。傳回 HTTP 錯誤的範例： // Example to return a HTTP error code RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/user/userInput.jsp\"); if (rd == null) { // messages is a resource bundle with all message keys and values response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, messages.getMessage(ErrorKeys.ERROR_USERNAME_INVALID)); } 作為最後的手段，Servlet 可以擲出異常狀況，它必須是下列類別之一的子類別：- RuntimeException- ServletException- IOException[2-b] JSP 錯誤機制 JSP 頁面依照下列範例所示來定義 errorPage 指引，從而提供了執行時期異常狀況的處理機制： &lt;%@ page errorPage=\"/errors/userValidation.jsp\" %&gt; 未捕捉的 JSP 異常狀況是轉遞到指定的 errorPage，而原始異常狀況則設在稱為 javax.servlet.jsp.jspException 的要求參數中。錯誤頁面必須包含 isErrorPage 指引，如下所示： &lt;%@ page isErrorPage=\"true\" %&gt; isErrorPage 指引會使 \"exception\" 變數起始設定為所擲出的異常狀況物件。[3] 呈現錯誤J2SE Internationalization API 提供用來提出應用程式資源以及將訊息格式化的公用程式類別，其中包括：(a) 資源組(b) 訊息格式化[3-a] 資源組資源組會將本地化的資料與使用它的原始碼分開，從而支援國際化。每個資源組都會儲存特定語言環境之鍵值配對的對映。通常是利用或延伸 java.util.PropertyResourceBundle，它會將內容儲存在外部內容檔中，如下列範例所示： ################################################ # ErrorMessages.properties ################################################ # required user name error message error.username.required=User name field is required # invalid user name format error.username.alphanumeric=User name must be alphanumeric # duplicate user name error message error.username.duplicate=User name {0} already exists, please choose another one ... 定義多重資源可以支援不同的語言環境（因此稱為資源組）。例如，定義 ErrorMessages_fr.properties 可以支援資源組系列的法國成員。如果要求之語言環境的資源成員不存在，便會使用預設成員。在上述範例中，預設資源是 ErrorMessages.properties。在上述範例中，預設資源是 ErrorMessages.properties。依使用者的語言環境而定，應用程式（JSP 或 Servlet）會從適當的資源擷取內容。[3-b] 訊息格式化J2SE 標準類別 java.util.MessageFormat 提供以取代位置保留元來建立訊息的一般方式。MessageFormat 物件包含內嵌了格式指定元的型樣字串，如下所示： // Example to show how to format a message using placeholder parameters String pattern = \"User name {0} already exists, please choose another one\"; String userName = request.getParameter(\"user_name\"); Object[] args = new Object[1]; args[0] = userName; String message = MessageFormat.format(pattern, args); 以下是利用 ResourceBundle 和 MessageFormat 來呈現錯誤訊息的更綜合性的範例： // Example to render an error message from a localized ErrorMessages resource (properties file) // Utility class to retrieve locale-specific error messages public Class ErrorMessageResource { // Returns the error message for the specified error key in the environment locale public String getErrorMessage(String errorKey) { return getErrorMessage(errorKey, defaultLocale); } // Returns the error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Locale locale) { return getErrorMessage(errorKey, null, locale); } // Returns a formatted error message for the specified error key in the specified locale public String getErrorMessage(String errorKey, Object[] args, Locale locale) { // Get localized ErrorMessageResource ResourceBundle errorMessageResource = ResourceBundle.getBundle(\"ErrorMessages\", locale); // Get localized error message String errorMessage = errorMessageResource.getString(errorKey); if (args != null) { // Format the message using the specified placeholders args return MessageFormat.format(errorMessage, args); } else { return errorMessage; } } // default environment locale private Locale defaultLocale = Locale.getDefaultLocale(); } ... // Get the user's locale Locale userLocale = request.getLocale(); // Check if there were any validation errors Errors errors = (Errors)request.getAttribute(\"errors\"); if (errors != null &amp;&amp; errors.hasErrors()) { // iterate through errors and output error messages corresponding to the \"user_name\" property ArrayList userNameErrors = errors.getErrors(\"user_name\"); ListIterator iterator = userNameErrors.iterator(); while (iterator.hasNext()) { // Get the next error object Error error = (Error)iterator.next(); String errorMessage = ErrorMessageResource.getErrorMessage(error.getKey(), userLocale); output.write(errorMessage + \"\\r\\n\"); } } 建議您定義自訂 JSP 標籤（如 displayErrors）來疊代處理及呈現錯誤訊息，如上述範例所示。[4] 錯誤對映一般而言，「Servlet 儲存器」會傳回對應於回應狀態碼或異常狀況的預設錯誤頁面。您可以利用自訂錯誤頁面來指定狀態碼或異常狀況與 Web 資源之間的對映。在實務中，好的做法是開發不揭露內部錯誤狀態的靜態錯誤頁面（依預設，大部分 Servlet 儲存器都會報告內部錯誤訊息）。這項對映是依照下列範例所指定，配置在「Web 部署描述子 (web.xml)」中： &lt;!-- Mapping of HTTP error codes and application exceptions to error pages --&gt; &lt;error-page&gt; &lt;exception-type&gt;UserValidationException&lt;/exception-type&gt; &lt;location&gt;/errors/validationError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/exception-type&gt; &lt;location&gt;/errors/internalError.html&lt;/error-page&gt; &lt;/error-page&gt; &lt;error-page&gt; ... &lt;/error-page&gt; ... 建議的 Java 工具適用於伺服器端驗證的兩個主要的 Java 架構如下：[1] Jakarta 一般驗證器（整合 Struts 1.1）「Jakarta 一般驗證器」是依照上述說明來定義錯誤處理機制的 Java 架構。驗證規則配置在 XML 檔中，檔案定義了表單欄位的輸入驗證規則以及對應的驗證錯誤索引鍵。Struts 提供國際化支援，供您利用資源組和訊息格式化來建置本地化應用程式。利用「Struts 驗證器」驗證 loginForm 之 userName 欄位的範例： &lt;form-validation&gt; &lt;global&gt; ... &lt;validator name=\"required\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateRequired\" msg=\"errors.required\"&gt; &lt;/validator&gt; &lt;validator name=\"mask\" classname=\"org.apache.struts.validator.FieldChecks\" method=\"validateMask\" msg=\"errors.invalid\"&gt; &lt;/validator&gt; ... &lt;/global&gt; &lt;formset&gt; &lt;form name=\"loginForm\"&gt; &lt;!-- userName is required and is alpha-numeric case insensitive --&gt; &lt;field property=\"userName\" depends=\"required,mask\"&gt; &lt;!-- message resource key to display if validation fails --&gt; &lt;msg name=\"mask\" key=\"login.userName.maskmsg\"/&gt; &lt;arg0 key=\"login.userName.displayname\"/&gt; &lt;var&gt; &lt;var-name&gt;mask&lt;/var-name&gt; &lt;var-value&gt;^[a-zA-Z0-9]*$&lt;/var-value&gt; &lt;/var&gt; &lt;/field&gt; ... &lt;/form&gt; ... &lt;/formset&gt; &lt;/form-validation&gt; Struts JSP 標籤庫定義了有條件地顯示一組累計錯誤訊息的 \"errors\" 標籤，如下列範例所示： &lt;%@ page language=\"java\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-html.tld\" prefix=\"html\" %&gt; &lt;%@ taglib uri=\"/WEB-INF/struts-bean.tld\" prefix=\"bean\" %&gt; &lt;html:html&gt; &lt;head&gt; &lt;body&gt; &lt;html:form action=\"/logon.do\"&gt; &lt;table border=\"0\" width=\"100%\"&gt; &lt;tr&gt; &lt;th align=\"right\"&gt; &lt;html:errors property=\"username\"/&gt; &lt;bean:message key=\"prompt.username\"/&gt; &lt;/th&gt; &lt;td align=\"left\"&gt; &lt;html:text property=\"username\" size=\"16\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\"&gt; &lt;html:submit&gt;&lt;bean:message key=\"button.submit\"/&gt;&lt;/html:submit&gt; &lt;/td&gt; &lt;td align=\"right\"&gt; &lt;html:reset&gt;&lt;bean:message key=\"button.reset\"/&gt;&lt;/html:reset&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/html:form&gt; &lt;/body&gt; &lt;/html:html&gt; [2] JavaServer Faces 技術「JavaServer Faces 技術」是一組代表使用者介面元件、管理元件狀態、處理事件、驗證輸入，以及支援國際化的 Java API (JSR 127)。JavaServer Faces API 定義了 \"output_errors\" UIOutput 展現器，以顯示整個頁面的錯誤訊息，或指定之用戶端 ID 的相關錯誤訊息。利用 JavaServer Faces 驗證 loginForm 之 userName 欄位的範例： &lt;%@ taglib uri=\"https://docs.oracle.com/javaee/6/tutorial/doc/glxce.html\" prefix=\"h\" %&gt; &lt;%@ taglib uri=\"http://mrbool.com/how-to-create-a-login-validation-with-jsf-java-server-faces/27046\" prefix=\"f\" %&gt; ... &lt;jsp:useBean id=\"UserBean\" class=\"myApplication.UserBean\" scope=\"session\" /&gt; &lt;f:use_faces&gt; &lt;h:form formName=\"loginForm\" &gt; &lt;h:input_text id=\"userName\" size=\"20\" modelReference=\"UserBean.userName\"&gt; &lt;f:validate_required/&gt; &lt;f:validate_length minimum=\"8\" maximum=\"20\"/&gt; &lt;/h:input_text&gt; &lt;!-- display errors if present --&gt; &lt;h:output_errors id=\"loginErrors\" clientId=\"userName\"/&gt; &lt;h:command_button id=\"submit\" label=\"Submit\" commandName=\"submit\" /&gt;&lt;p&gt; &lt;/h:form&gt; &lt;/f:use_faces&gt; 參照Java API 1.3 - https://www.oracle.com/java/technologies/java-archive-13docs-downloads.htmlJava API 1.4 - https://www.oracle.com/java/technologies/java-archive-142docs-downloads.htmlJava Servlet API 2.3 - https://mvnrepository.com/artifact/javax.servlet/javax.servlet-apiJava 正規表示式套件 - http://jakarta.apache.org/regexp/Jakarta 驗證器 - http://jakarta.apache.org/commons/validator/JavaServer Faces 技術 - http://www.javaserverfaces.org/** 驗證輸入資料：雖然為了使用者的方便，可以在用戶端層提供資料驗證，但一律必須在伺服器層執行資料驗證。用戶端驗證原本就不安全，因為它們可以輕易略過，例如：停用 JavaScript。好的設計通常需要 Web 應用程式架構提供伺服器端公用程式常式來驗證下列項目：[1] 必要欄位[2] 欄位資料類型（依預設，所有 HTTP 要求參數都是 String）[3] 欄位長度[4] 欄位範圍[5] 欄位選項[6] 欄位型樣[7] Cookie 值[8] HTTP 回應在實務中，好的做法是實作一或多個驗證各個應用程式參數的函數。下列各節說明一些檢查範例。[1] 必要欄位一律檢查確認欄位不是空值，欄位長度大於零，且不含在前端及尾端的空格。如何驗證必要欄位的範例： // PHP example to validate required fields function validateRequired($input) { ... $pass = false; if (strlen(trim($input))&gt;0){ $pass = true; } return $pass; ... } ... if (validateRequired($fieldName)) { // fieldName is valid, continue processing request ... } [2] 欄位資料類型在 Web 應用程式中，所輸入的輸入參數設定不良。例如，所有 HTTP 要求參數或 Cookie 值都是 String 類型。開發人員負責確認輸入的資料類型正確。[3] 欄位長度一律確定輸入參數（HTTP 要求參數或 Cookie 值）在長度下限及/或長度上限的範圍內。[4] 欄位範圍一律確定輸入參數在函數需求定義的範圍內。[5] 欄位選項Web 應用程式通常會向使用者呈現一組可供選擇的選項（例如：使用 SELECT HTML 標籤），但無法執行伺服器端驗證來確保所選的值是容許的選項之一。請記住，惡意的使用者可以輕易修改任何選項值。一律檢查使用者輸入是否符合功能需求所定義的型樣。[6] 欄位型樣 一律檢查使用者輸入是否符合功能需求所定義的型樣。 比方說，如果 userName 欄位只應接受英數字元，且不區分大小寫，請使用下列正規表示式：^[a-zA-Z0-9]+$[7] Cookie 值依應用程式需求而定，相同的驗證規則（說明如上）也適用於 Cookie 值，例如：驗證必要的值、驗證長度，等等。[8] HTTP 回應[8-1] 過濾使用者輸入如果要保護應用程式免於遭受跨網站指令碼，開發人員應該將機密字元轉換成對應的字元實體來消毒 HTML。以下是 HTML 區分字元：&lt; &gt; \" ' % ; ) ( &amp; +PHP 包括一些 htmlentities() 之類的自動化消毒公用程式函數： $input = htmlentities($input, ENT_QUOTES, 'UTF-8'); 此外，為了避免「跨網站指令碼」的 UTF-7 變式，您應該明確定義回應的 Content-Type 標頭，例如： &lt;?php header('Content-Type: text/html; charset=UTF-8'); ?&gt; [8-2] 維護 Cookie 安全當機密資料儲存在 Cookie 中，且透過 SSL 來傳輸它時，請務必先在 HTTP 回應中設定 Cookie 的安全旗標。這會指示瀏覽器只透過 SSL 連線來使用這個 Cookie。您可以利用下列程式碼範例來維護 Cookie 安全： &lt;$php $value = \"some_value\"; $time = time()+3600; $path = \"/application/\"; $domain = \".example.com\"; $secure = 1; setcookie(\"CookieName\", $value, $time, $path, $domain, $secure, TRUE); ?&gt; 此外，我們建議您使用 HttpOnly 旗標。當 HttpOnly 旗標設為 TRUE 時，只能透過 HTTP 通訊協定來存取 Cookie。這表示無法用 JavaScript 之類的 Scripting 語言存取 Cookie。這個設定有助於實際減少透過 XSS 攻擊來盜用身分的情況（不過，並非所有瀏覽器都支援）。PHP 5.2.0 新增 HttpOnly 旗標。參照[1] 利用「HTTP 專用 Cookie」緩和「跨網站指令碼」：http://msdn2.microsoft.com/en-us/library/ms533046.aspx[2] PHP 安全聯盟：http://phpsec.org/[3] PHP &amp; Web 應用程式安全部落格 (Chris Shiflett)： http://shiflett.org/<w:br w:type=\"page\"/>"
        },
        {
            "name": "遺漏「查閱者原則」安全標頭",
            "goal_url": "https://testasp.vulnweb.com",
            "severity": "參考資訊",
            "cvss": "0.0",
            "cvss_vector": "AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N/E:X/RL:O/RC:C/CR:X/IR:X/AR:X/MAV:X/MAC:X/MPR:X/MUI:X/MS:X/MC:X/MI:X/MA:X",
            "cve": "",
            "url": "http://testasp.vulnweb.com/",
            "entity": "testasp.vulnweb.com (Page)",
            "risk": "有可能收集 Web 應用程式相關的機密性資訊，如：使用者名稱、密碼、機器名稱及/或機密檔案位置\n有可能說服無經驗而易受騙的使用者提供機密性資訊，如：使用者名稱、密碼、信用卡號碼、社會保險號碼等等\n",
            "cause": "不安全的 Web 應用程式設計或配置",
            "solution": "配置您的伺服器，以搭配安全原則使用「查閱者原則」標頭",
            "mark": "",
            "solution_description": "有可能收集有關 Web 應用程式的機密資訊，例如使用者名稱、密碼、機器名稱和/或機密檔案位置有可能說服天真的使用者提供機密資訊，例如使用者名稱、密碼、信用卡號碼、社會安全碼等等查閱者原則的值缺少或不適當可能會導致 URL 洩漏，即使是 URL 中所含的機密資訊，都會向跨網站洩漏。這是一部分的規則集，可檢查是否設有查閱者原則，若有的話可以測試其設定。「查閱者原則」標頭會在查閱者標頭中定義可提供的資料，並且在目的地的 (document.referrer) 定義導覽和 iframe。此標頭的設計是為了要修改瀏覽器呈現頁面的方式，藉此避免跨網域的查閱者洩漏。正確設定標頭值很重要，設定方式不要妨礙網站的正常運作。查閱者標頭是一個要求標頭，可表示流量來自哪個網站。如果沒有設有適當的防護，URL 本身，甚至是包含在 URL 中的機密資訊，都會向跨網站洩漏。「no-referrer-when-downgrade」和「unsafe-url」是會洩露第三方網站完整 URL 的原則。剩餘的原則為「no-referrer」、「origin」、「origin-when-cross-origin」、「same-origin」、「strict-origin」、「strict-origin-when-cross-origin」。詳情請參閱下方連結。",
            "solution_suggest": "設定伺服器以傳送「查閱者原則」標頭。建議透過查閱者原則標頭的目錄安全值，設定查閱者原則標頭。如下所示：\"strict-origin-when-cross-origin\" 提供更高的隱私權。有了此原則，只有來源會在跨來源要求的查閱者標頭中傳送。如果是 Google Chrome，請參閱： https://developers.google.com/web/updates/2020/07/referrer-policy-new-chrome-default如果是 Firefox，請參閱： https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy.<w:br w:type=\"page\"/>"
        }
    ],
    "information": [
        {
            "version_web": "10.8.0",
            "web_url": "https://testasp.vulnweb.com",
            "start_time": "2025/2/5 下午11:23:07"
        }
    ]
}